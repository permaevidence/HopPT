import SwiftUI
import CoreData
import Combine
import MarkdownUI
import Foundation
import PhotosUI
import UniformTypeIdentifiers
import Vision
import PDFKit
import UIKit
import CoreTransferable
import AVFoundation
import NaturalLanguage
import Security


@main
struct localChatApp: App {
    let persistenceController = PersistenceController.shared

    @StateObject private var settings = AppSettings()
    @StateObject private var chatVM: ChatViewModel

    init() {
        let ctx = PersistenceController.shared.container.viewContext
        let s   = AppSettings()
        _chatVM   = StateObject(wrappedValue: ChatViewModel(context: ctx, settings: s))
        _settings = StateObject(wrappedValue: s)
    }

    var body: some Scene {
        WindowGroup {
            ContentView(viewModel: chatVM)
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
                .environmentObject(settings)
                .preferredColorScheme(.light)
        }
    }
}

struct EndpointConfig: Identifiable, Codable, Equatable, Hashable {
    var id: UUID = UUID()
    var name: String = ""
    var apiBase: String = ""
    var selectedModels: [String] = []
    var preferredModel: String? = nil
    
    // API key is NOT part of Codable - stored separately in Keychain
    var apiKey: String = ""
    
    enum CodingKeys: String, CodingKey {
        case id, name, apiBase, selectedModels, preferredModel
        // apiKey intentionally excluded
    }
    
    // Keychain key for this endpoint's API key
    var keychainKey: String { "endpoint_apiKey_\(id.uuidString)" }
    
    // Load API key from Keychain
    mutating func loadApiKeyFromKeychain() {
        apiKey = KeychainHelper.load(for: keychainKey) ?? ""
    }
    
    // Save API key to Keychain
    func saveApiKeyToKeychain() {
        if apiKey.isEmpty {
            KeychainHelper.delete(for: keychainKey)
        } else {
            KeychainHelper.save(apiKey, for: keychainKey)
        }
    }
    
    // Delete API key from Keychain (call when deleting endpoint)
    func deleteApiKeyFromKeychain() {
        KeychainHelper.delete(for: keychainKey)
    }
}

enum DeviceSupport {
    static let isIPhone13OrNewer: Bool = {
        var systemInfo = utsname(); uname(&systemInfo)
        let raw = withUnsafeBytes(of: &systemInfo.machine) { ptr -> String in
            let data = Data(ptr)
            return String(decoding: data, as: UTF8.self)
                .trimmingCharacters(in: .controlCharacters)
        }
        guard raw.hasPrefix("iPhone") else { return false }
        let digits = raw.dropFirst("iPhone".count)
        guard let comma = digits.firstIndex(of: ","),
              let major = Int(digits[..<comma]) else { return false }
        return major >= 14          // iPhone14,* ⇒ iPhone 13 generation
    }()
}

final class AppSettings: ObservableObject {
    // --- Bridge fields used by the rest of the app (always reflect ACTIVE endpoint) ---
    @Published var apiBase: String = "" { didSet { UserDefaults.standard.set(apiBase, forKey: "apiBase") } }
    
    // API key now uses Keychain
    @Published var apiKey: String = "" {
        didSet {
            if apiKey.isEmpty {
                KeychainHelper.delete(for: "bridge_apiKey")
            } else {
                KeychainHelper.save(apiKey, for: "bridge_apiKey")
            }
            // Sync into active endpoint
            if let idx = endpoints.firstIndex(where: { $0.id == activeEndpointID }) {
                if endpoints[idx].apiKey != apiKey {
                    endpoints[idx].apiKey = apiKey
                    endpoints[idx].saveApiKeyToKeychain()
                }
            }
        }
    }
    
    @Published var model: String = "" {
        didSet {
            UserDefaults.standard.set(model, forKey: "model")
            if let idx = endpoints.firstIndex(where: { $0.id == activeEndpointID }) {
                if endpoints[idx].preferredModel != model {
                    endpoints[idx].preferredModel = model
                    saveEndpoints()
                }
            }
        }
    }
    
    @Published var selectedModels: [String] = [] {
        didSet {
            UserDefaults.standard.set(selectedModels, forKey: "selectedModels")
            ensureActiveModelIsValid()
            if let idx = endpoints.firstIndex(where: { $0.id == activeEndpointID }) {
                if endpoints[idx].selectedModels != selectedModels {
                    endpoints[idx].selectedModels = selectedModels
                    saveEndpoints()
                }
            }
        }
    }

    // --- Web search config (now using Keychain for API keys) ---
    @Published var serperApiKey: String = "" {
        didSet {
            if serperApiKey.isEmpty {
                KeychainHelper.delete(for: "serperApiKey")
            } else {
                KeychainHelper.save(serperApiKey, for: "serperApiKey")
            }
        }
    }
    
    @Published var jinaApiKey: String = "" {
        didSet {
            if jinaApiKey.isEmpty {
                KeychainHelper.delete(for: "jinaApiKey")
            } else {
                KeychainHelper.save(jinaApiKey, for: "jinaApiKey")
            }
        }
    }
    
    @Published private var scrapingModeStorage: String = "" { didSet { UserDefaults.standard.set(scrapingModeStorage, forKey: "scrapingMode") } }
    var scrapingMode: ScrapingMode {
        get { ScrapingMode(rawValue: scrapingModeStorage) ?? .localWebKit }
        set { scrapingModeStorage = newValue.rawValue }
    }

    // --- Multi-endpoint store ---
    @Published var endpoints: [EndpointConfig] = [] {
        didSet {
            saveEndpoints()
            syncActiveEndpointFields()
        }
    }
    
    @Published var activeEndpointID: UUID? = nil {
        didSet {
            UserDefaults.standard.set(activeEndpointID?.uuidString, forKey: "activeEndpointID")
            syncActiveEndpointFields()
        }
    }
    
    // TTS toggle
    @Published var ttsEnabled: Bool = false {
        didSet { UserDefaults.standard.set(ttsEnabled, forKey: "ttsEnabled") }
    }
    
    var activeEndpoint: EndpointConfig? {
        endpoints.first(where: { $0.id == activeEndpointID }) ?? endpoints.first
    }

    // --- Init with migration ---
    init() {
        let defaults = UserDefaults.standard

        // Old keys (for migration)
        let initialApiBase = defaults.string(forKey: "apiBase") ?? ""
        let initialModel = defaults.string(forKey: "model") ?? ""
        let initialScraping = defaults.string(forKey: "scrapingMode") ?? ScrapingMode.localWebKit.rawValue
        let initialSelected: [String] = (defaults.array(forKey: "selectedModels") as? [String]) ?? (initialModel.isEmpty ? [] : [initialModel])
        
        // Migrate API keys from UserDefaults to Keychain (one-time)
        let initialApiKey: String
        if let oldApiKey = defaults.string(forKey: "apiKey"), !oldApiKey.isEmpty {
            KeychainHelper.save(oldApiKey, for: "bridge_apiKey")
            defaults.removeObject(forKey: "apiKey") // Remove from UserDefaults after migration
            initialApiKey = oldApiKey
        } else {
            initialApiKey = KeychainHelper.load(for: "bridge_apiKey") ?? ""
        }
        
        let initialSerper: String
        if let oldSerper = defaults.string(forKey: "serperApiKey"), !oldSerper.isEmpty {
            KeychainHelper.save(oldSerper, for: "serperApiKey")
            defaults.removeObject(forKey: "serperApiKey")
            initialSerper = oldSerper
        } else {
            initialSerper = KeychainHelper.load(for: "serperApiKey") ?? ""
        }
        
        let initialJina: String
        if let oldJina = defaults.string(forKey: "jinaApiKey"), !oldJina.isEmpty {
            KeychainHelper.save(oldJina, for: "jinaApiKey")
            defaults.removeObject(forKey: "jinaApiKey")
            initialJina = oldJina
        } else {
            initialJina = KeychainHelper.load(for: "jinaApiKey") ?? ""
        }

        // Load endpoints and their API keys from Keychain
        if let data = defaults.data(forKey: "endpoints.v1"),
           var decoded = try? JSONDecoder().decode([EndpointConfig].self, from: data) {
            // Load API keys from Keychain for each endpoint
            for i in decoded.indices {
                decoded[i].loadApiKeyFromKeychain()
            }
            self.endpoints = decoded
        } else {
            var migrated: [EndpointConfig] = []
            if !initialApiBase.isEmpty || !initialApiKey.isEmpty || !initialSelected.isEmpty {
                let guessName: String = {
                    let b = initialApiBase.lowercased()
                    if b.contains("localhost") || b.contains("127.0.0.1") { return "Local" }
                    return "Default"
                }()
                var newEndpoint = EndpointConfig(
                    name: guessName,
                    apiBase: initialApiBase,
                    selectedModels: initialSelected,
                    preferredModel: initialModel.isEmpty ? initialSelected.first : initialModel
                )
                newEndpoint.apiKey = initialApiKey
                newEndpoint.saveApiKeyToKeychain()
                migrated = [newEndpoint]
            }
            self.endpoints = migrated
            saveEndpoints()
        }

        if let s = defaults.string(forKey: "activeEndpointID"),
           let uuid = UUID(uuidString: s),
           endpoints.contains(where: { $0.id == uuid }) {
            self.activeEndpointID = uuid
        } else {
            self.activeEndpointID = endpoints.first?.id
        }

        self.serperApiKey = initialSerper
        self.jinaApiKey = initialJina
        self.scrapingModeStorage = initialScraping
        
        self.apiBase = initialApiBase
        self.apiKey = initialApiKey
        self.model = initialModel
        self.selectedModels = initialSelected
        self.ttsEnabled = defaults.bool(forKey: "ttsEnabled")

        syncActiveEndpointFieldsWithModelPreservation()

        defaults.removeObject(forKey: "temperature")
    }
    
    private func syncActiveEndpointFieldsWithModelPreservation() {
        guard let ep = activeEndpoint else {
            if endpoints.isEmpty {
                apiBase = ""; apiKey = ""; model = ""; selectedModels = []
            }
            return
        }

        if apiBase != ep.apiBase { apiBase = ep.apiBase }
        if apiKey != ep.apiKey { apiKey = ep.apiKey }
        if selectedModels != ep.selectedModels { selectedModels = ep.selectedModels }

        let currentSavedModel = UserDefaults.standard.string(forKey: "model") ?? ""
        
        if !currentSavedModel.isEmpty && ep.selectedModels.contains(currentSavedModel) {
            model = currentSavedModel
            if let idx = endpoints.firstIndex(where: { $0.id == ep.id }) {
                if endpoints[idx].preferredModel != currentSavedModel {
                    endpoints[idx].preferredModel = currentSavedModel
                    saveEndpoints()
                }
            }
        } else {
            let targetModel = ep.preferredModel ?? ep.selectedModels.first ?? ""
            if model != targetModel { model = targetModel }
        }
        
        ensureActiveModelIsValid()
    }

    private func saveEndpoints() {
        // Save API keys to Keychain for each endpoint
        for ep in endpoints {
            ep.saveApiKeyToKeychain()
        }
        // Save the rest (without apiKey) to UserDefaults
        if let data = try? JSONEncoder().encode(endpoints) {
            UserDefaults.standard.set(data, forKey: "endpoints.v1")
        }
    }

    private func syncActiveEndpointFields() {
        guard let ep = activeEndpoint else {
            if endpoints.isEmpty && !(apiBase.isEmpty && apiKey.isEmpty && model.isEmpty && selectedModels.isEmpty) {
                apiBase = ""; apiKey = ""; model = ""; selectedModels = []
            }
            return
        }

        if apiBase != ep.apiBase { apiBase = ep.apiBase }
        if apiKey != ep.apiKey { apiKey = ep.apiKey }
        if selectedModels != ep.selectedModels { selectedModels = ep.selectedModels }

        if !model.isEmpty && ep.selectedModels.contains(model) {
            if ep.preferredModel != model {
                if let idx = endpoints.firstIndex(where: { $0.id == ep.id }) {
                    endpoints[idx].preferredModel = model
                    saveEndpoints()
                }
            }
        } else {
            let targetModel = ep.preferredModel ?? ep.selectedModels.first ?? ""
            if model != targetModel { model = targetModel }
        }
        
        ensureActiveModelIsValid()
    }

    func upsertEndpoint(_ ep: EndpointConfig) {
        ep.saveApiKeyToKeychain()
        if let idx = endpoints.firstIndex(where: { $0.id == ep.id }) {
            endpoints[idx] = ep
        } else {
            endpoints.append(ep)
        }
    }

    func deleteEndpoint(_ ep: EndpointConfig) {
        ep.deleteApiKeyFromKeychain()
        endpoints.removeAll { $0.id == ep.id }
        if activeEndpointID == ep.id {
            activeEndpointID = endpoints.first?.id
        }
    }

    func setActiveModel(_ model: String, on endpointID: UUID) {
        activeEndpointID = endpointID
        self.model = model
        if let idx = endpoints.firstIndex(where: { $0.id == endpointID }) {
            if endpoints[idx].preferredModel != model {
                endpoints[idx].preferredModel = model
                saveEndpoints()
            }
        }
    }

    var chatCompletionsURL: URL? {
        let base = apiBase.trimmingCharacters(in: .whitespacesAndNewlines)
        guard
            !base.isEmpty,
            let baseURL = URL(string: base),
            let scheme = baseURL.scheme, (scheme == "http" || scheme == "https"),
            baseURL.host != nil
        else { return nil }
        return baseURL.appendingPathComponent("chat/completions")
    }

    var modelsURL: URL? {
        let base = apiBase.trimmingCharacters(in: .whitespacesAndNewlines)
        guard
            !base.isEmpty,
            let baseURL = URL(string: base),
            let scheme = baseURL.scheme, (scheme == "http" || scheme == "https"),
            baseURL.host != nil
        else { return nil }
        return baseURL.appendingPathComponent("models")
    }

    var ollamaTagsURL: URL? {
        let base = apiBase.trimmingCharacters(in: .whitespacesAndNewlines)
        guard
            !base.isEmpty,
            let baseURL = URL(string: base),
            let scheme = baseURL.scheme, (scheme == "http" || scheme == "https"),
            baseURL.host != nil
        else { return nil }
        var comps = URLComponents(url: baseURL, resolvingAgainstBaseURL: false)
        comps?.path = "/api/tags"
        return comps?.url
    }

    var isChatConfigured: Bool {
        !apiBase.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !model.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }

    var authHeaders: [String:String] {
        let key = apiKey.trimmingCharacters(in: .whitespacesAndNewlines)
        return key.isEmpty ? [:] : ["Authorization": "Bearer \(key)"]
    }

    func ensureActiveModelIsValid() {
        if !selectedModels.contains(model) {
            model = selectedModels.first ?? ""
        }
    }
}

// MARK: - Core Data Stack
class PersistenceController {
    static let shared = PersistenceController()
    let container: NSPersistentContainer
    
    init() {
        // Create the model programmatically
        let model = NSManagedObjectModel()
        
        // Create both entities first
        let messageEntity = NSEntityDescription()
        messageEntity.name = "Message"
        messageEntity.managedObjectClassName = "Message"
        
        let conversationEntity = NSEntityDescription()
        conversationEntity.name = "Conversation"
        conversationEntity.managedObjectClassName = "Conversation"
        
        // Message attributes
        let messageIdAttribute = NSAttributeDescription()
        messageIdAttribute.name = "id"
        messageIdAttribute.attributeType = .UUIDAttributeType
        messageIdAttribute.isOptional = false
        
        let contentAttribute = NSAttributeDescription()
        contentAttribute.name = "content"
        contentAttribute.attributeType = .stringAttributeType
        contentAttribute.isOptional = false
        
        let isUserAttribute = NSAttributeDescription()
        isUserAttribute.name = "isUser"
        isUserAttribute.attributeType = .booleanAttributeType
        isUserAttribute.isOptional = false
        
        let timestampAttribute = NSAttributeDescription()
        timestampAttribute.name = "timestamp"
        timestampAttribute.attributeType = .dateAttributeType
        timestampAttribute.isOptional = false
        
        let modelNameAttribute = NSAttributeDescription()
        modelNameAttribute.name = "modelName"
        modelNameAttribute.attributeType = .stringAttributeType
        modelNameAttribute.isOptional = true
        
        // Conversation attributes
        let convIdAttribute = NSAttributeDescription()
        convIdAttribute.name = "id"
        convIdAttribute.attributeType = .UUIDAttributeType
        convIdAttribute.isOptional = false
        
        let titleAttribute = NSAttributeDescription()
        titleAttribute.name = "title"
        titleAttribute.attributeType = .stringAttributeType
        titleAttribute.isOptional = false
        
        let createdAtAttribute = NSAttributeDescription()
        createdAtAttribute.name = "createdAt"
        createdAtAttribute.attributeType = .dateAttributeType
        createdAtAttribute.isOptional = false
        
        let updatedAtAttribute = NSAttributeDescription()
        updatedAtAttribute.name = "updatedAt"
        updatedAtAttribute.attributeType = .dateAttributeType
        updatedAtAttribute.isOptional = true
        
        // Create relationships after entities are defined
        let conversationRelation = NSRelationshipDescription()
        conversationRelation.name = "conversation"
        conversationRelation.destinationEntity = conversationEntity
        conversationRelation.maxCount = 1
        conversationRelation.deleteRule = .nullifyDeleteRule
        conversationRelation.isOptional = true
        
        let messagesRelation = NSRelationshipDescription()
        messagesRelation.name = "messages"
        messagesRelation.destinationEntity = messageEntity
        messagesRelation.maxCount = 0
        messagesRelation.deleteRule = .cascadeDeleteRule
        messagesRelation.isOptional = true
        messagesRelation.isOrdered = true
        
        // Set inverse relationships
        conversationRelation.inverseRelationship = messagesRelation
        messagesRelation.inverseRelationship = conversationRelation
        
        // Add properties to entities
        messageEntity.properties = [messageIdAttribute, contentAttribute, isUserAttribute, timestampAttribute, modelNameAttribute, conversationRelation]
        conversationEntity.properties = [
          convIdAttribute, titleAttribute, createdAtAttribute, updatedAtAttribute, messagesRelation
        ]
        
        // Add entities to model
        model.entities = [messageEntity, conversationEntity]
        
        // Initialize container with the custom model
        container = NSPersistentContainer(name: "ChatModel", managedObjectModel: model)
        
        if let desc = container.persistentStoreDescriptions.first {
            desc.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
            desc.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
        }
        
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Core Data failed to load: \(error.localizedDescription)")
            }
        }
    }
}

// MARK: - Core Data Models
@objc(Message)
class Message: NSManagedObject {
    @NSManaged var id: UUID
    @NSManaged var content: String
    @NSManaged var isUser: Bool
    @NSManaged var timestamp: Date
    @NSManaged var conversation: Conversation?
    @NSManaged var modelName: String?
}

@objc(Conversation)
class Conversation: NSManagedObject {
    @NSManaged var id: UUID
    @NSManaged var title: String
    @NSManaged var createdAt: Date
    @NSManaged var updatedAt: Date?
    @NSManaged var messages: NSOrderedSet?
}

// MARK: - LMStudio API Service
class LMStudioService: ObservableObject {
    private let settings: AppSettings
    private var cancellables = Set<AnyCancellable>()

    // ⬇️ ADD
    private var activeSession: URLSession?
    private var activeTask: URLSessionDataTask?

    init(settings: AppSettings) {
        self.settings = settings
    }

    func streamChat(messages: [[String: String]],
                    onChunk: @escaping (String) -> Void,
                    onComplete: @escaping () -> Void,
                    onError: @escaping (Error) -> Void) {

        guard let url = settings.chatCompletionsURL else {
            onError(NSError(domain: "Invalid API Base", code: 0, userInfo: [NSLocalizedDescriptionKey: "apiBase is invalid"]))
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        for (k, v) in settings.authHeaders { request.setValue(v, forHTTPHeaderField: k) }
        
        request.timeoutInterval = 15 * 60
        
        let cfg = URLSessionConfiguration.default
        cfg.timeoutIntervalForRequest = 15 * 60
        cfg.timeoutIntervalForResource = 15 * 60

        let body: [String: Any] = [
            "model": settings.model,
            "messages": messages,
            "stream": true
        ]
        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        let delegate = StreamDelegate(onChunk: onChunk, onComplete: onComplete, onError: onError)
        // ⬇️ CHANGE this block so we retain session/task
        let session = URLSession(configuration: cfg, delegate: delegate, delegateQueue: nil)
        self.activeSession = session
        let task = session.dataTask(with: request)
        self.activeTask = task
        task.resume()
    }

    // ⬇️ ADD
    func cancelStreaming() {
        activeTask?.cancel()
        activeTask = nil
        activeSession?.invalidateAndCancel()
        activeSession = nil
    }
}

class StreamDelegate: NSObject, URLSessionDataDelegate {
    private let onChunk: (String) -> Void
    private let onComplete: () -> Void
    private let onError: (Error) -> Void

    private var buffer = Data()
    private var finished = false
    private var thinkFilter = ThinkFilter()

    init(onChunk: @escaping (String) -> Void,
         onComplete: @escaping () -> Void,
         onError: @escaping (Error) -> Void) {
        self.onChunk = onChunk
        self.onComplete = onComplete
        self.onError = onError
    }

    private func finishIfNeeded() {
        guard !finished else { return }
        finished = true
        DispatchQueue.main.async { self.onComplete() }
    }

    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
        buffer.append(data)

        // Support both LF and CRLF separators for SSE frames
        let sepLF = "\n\n".data(using: .utf8)!
        let sepCRLF = "\r\n\r\n".data(using: .utf8)!

        while true {
            guard let range = buffer.range(of: sepLF) ?? buffer.range(of: sepCRLF) else { break }

            let eventData = buffer.subdata(in: 0..<range.lowerBound)
            buffer.removeSubrange(0..<range.upperBound)

            guard let str = String(data: eventData, encoding: .utf8) else { continue }

            for line in str.split(separator: "\n") {
                guard line.hasPrefix("data:") else { continue }

                let payload = String(line.dropFirst(5)).trimmingCharacters(in: .whitespacesAndNewlines)

                // End-of-stream from OpenAI-style SSE
                if payload == "[DONE]" {
                    finishIfNeeded()
                    return
                }

                if let jsonData = payload.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any],
                   let choices = json["choices"] as? [[String: Any]] {

                    // Prefer streaming delta, fall back to full message if a server sends that
                    if let delta = choices.first?["delta"] as? [String: Any],
                       let content = delta["content"] as? String, !content.isEmpty {
                        let filtered = self.thinkFilter.feed(content)
                        if !filtered.isEmpty {
                            DispatchQueue.main.async { self.onChunk(filtered) }
                        }
                    } else if let message = choices.first?["message"] as? [String: Any],
                              let content = message["content"] as? String, !content.isEmpty {
                        let filtered = self.thinkFilter.feed(content)
                        if !filtered.isEmpty {
                            DispatchQueue.main.async { self.onChunk(filtered) }
                        }
                    }
                }
            }
        }
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if let error = error {
            // If a network error happens after we already finished, ignore it.
            guard !finished else { return }
            finished = true
            DispatchQueue.main.async { self.onError(error) }
        } else {
            // Connection closed cleanly without an explicit [DONE]
            finishIfNeeded()
        }
    }
}

fileprivate struct ThinkFilter {
    private(set) var inThink = false
    private var pending = ""

    // Markers many “thinking” models use
    private let startTags = ["<|begin_of_thought|>", "<think>", "```thinking", "```thoughts"]
    private let endTags   = ["<|end_of_thought|>",   "</think>", "```"]

    mutating func feed(_ newText: String) -> String {
        pending += newText
        var visible = ""

        while true {
            if inThink {
                if let r = earliestRange(in: pending, of: endTags) {
                    let after = pending[r.upperBound...]
                    pending = String(after)
                    inThink = false
                    continue
                } else {
                    // Keep a small tail to catch boundary-crossing end tags
                    if pending.count > 2048 { pending = String(pending.suffix(512)) }
                    return visible
                }
            } else {
                if let r = earliestRange(in: pending, of: startTags) {
                    // Emit anything before the think-start
                    visible += String(pending[..<r.lowerBound])
                    let after = pending[r.upperBound...]
                    pending = String(after)
                    inThink = true
                    continue
                } else {
                    visible += pending
                    pending.removeAll(keepingCapacity: false)
                    return visible
                }
            }
        }
    }

    private func earliestRange(in s: String, of tags: [String]) -> Range<String.Index>? {
        var best: Range<String.Index>?
        for t in tags {
            if let r = s.range(of: t) {
                if best == nil || r.lowerBound < best!.lowerBound { best = r }
            }
        }
        return best
    }
}

struct Attachment: Identifiable, Equatable, Hashable {
    enum Kind: String { case image, pdf }
    let id = UUID()
    let kind: Kind
    var filename: String
    var text: String
}

// Parsed copy of what's inside the "### Attachments" section of a saved user message.
struct ParsedAttachment: Identifiable, Equatable, Hashable {
    let id = UUID()
    let index: Int
    let filename: String
    let kind: Attachment.Kind
    let text: String
}

fileprivate func splitUserContentAndAttachments(_ content: String) -> (clean: String, attachments: [ParsedAttachment]) {
    // If there's no "### Attachments" section, show the message as-is.
    guard let headerRange = content.range(of: "### Attachments") else {
        return (content, [])
    }

    let cleanText = String(content[..<headerRange.lowerBound]).trimmingCharacters(in: .whitespacesAndNewlines)
    let tail = String(content[headerRange.upperBound...])

    var results: [ParsedAttachment] = []
    let nsTail = tail as NSString

    // Matches blocks like:
    // (1) filename.ext [image]   \n
    // ```                        \n
    // ...text...                 \n
    // ```
    let pattern = #"^\((\d+)\)\s+(.+?)\s+\[(image|pdf)\]\s*[\r\n]+```[\r\n]?([\s\S]*?)```"#

    do {
        let rx = try NSRegularExpression(
            pattern: pattern,
            options: [.dotMatchesLineSeparators, .anchorsMatchLines]
        )
        let matches = rx.matches(in: tail, options: [], range: NSRange(location: 0, length: nsTail.length))
        for m in matches {
            guard m.numberOfRanges >= 5 else { continue }
            let idxStr   = nsTail.substring(with: m.range(at: 1))
            let filename = nsTail.substring(with: m.range(at: 2)).trimmingCharacters(in: .whitespacesAndNewlines)
            let kindStr  = nsTail.substring(with: m.range(at: 3)).trimmingCharacters(in: .whitespacesAndNewlines)
            let text     = nsTail.substring(with: m.range(at: 4))

            let index = Int(idxStr) ?? (results.count + 1)
            let kind  = Attachment.Kind(rawValue: kindStr) ?? .image

            results.append(ParsedAttachment(index: index, filename: filename, kind: kind, text: text))
        }
    } catch {
        // If parsing fails, we just fall back to showing no attachment containers.
    }

    return (cleanText, results)
}

// MARK: - View Models
class ChatViewModel: ObservableObject {
    @Published var conversations: [Conversation] = []
    @Published var currentConversation: Conversation?
    @Published var messages: [Message] = []
    @Published var inputText = ""
    @Published var isLoading = false
    @Published var streamedResponse = ""
    @Published var useWebSearch = false
    @Published var webStatus: WebStatus? = nil
    @Published var pendingAttachments: [Attachment] = []
    @Published var isTTSSpeaking = false  // NEW: reflect TTS state for UI

    private let webPipeline: WebSearchPipeline
    private var streamToken = UUID()
    private var pipelineTask: Task<Void, Never>? = nil
    
    private let context: NSManagedObjectContext
    private let lmStudioService: LMStudioService
    private let settings: AppSettings
    private let ATTACHMENT_CHAR_LIMIT: Int? = nil // set to nil for no cap
    
    // NEW: TTS
    private let tts = TTSManager()
    private var cancellables = Set<AnyCancellable>()
    
    init(context: NSManagedObjectContext, settings: AppSettings) {
            self.context = context
            self.settings = settings
            self.lmStudioService = LMStudioService(settings: settings)
            self.webPipeline = WebSearchPipeline(settings: settings)
            loadConversations()

            // Observe TTS state so we can enable/disable the Stop button
            tts.$isSpeaking
                .receive(on: DispatchQueue.main)
                .sink { [weak self] in self?.isTTSSpeaking = $0 }
                .store(in: &cancellables)

            // If the toggle is turned off mid-stream, stop speaking immediately
            settings.$ttsEnabled
                .dropFirst()
                .receive(on: DispatchQueue.main)
                .sink { [weak self] enabled in
                    if !enabled { self?.tts.stop() }
                }
                .store(in: &cancellables)
        }
    
    // Expose a simple stop for the UI
        func stopTTS() {
            tts.stop()
        }
    
    func loadConversations(preserveSelection: Bool = false) {
        let request = NSFetchRequest<Conversation>(entityName: "Conversation")
        request.sortDescriptors = [
            NSSortDescriptor(key: "updatedAt", ascending: false),
            NSSortDescriptor(key: "createdAt", ascending: false)
        ]

        do {
            let currentID = currentConversation?.objectID
            conversations = try context.fetch(request)

            if preserveSelection, let currentID,
               let same = conversations.first(where: { $0.objectID == currentID }) {
                currentConversation = same
                loadMessages(for: same)
            } else if currentConversation == nil, let first = conversations.first {
                selectConversation(first)
            }
        } catch {
            print("Error loading conversations: \(error)")
        }
    }
    
    func createNewConversation() {
        let conversation = Conversation(context: context)
        conversation.id = UUID()
        conversation.title = "New Chat"
        conversation.createdAt = Date()
        conversation.updatedAt = conversation.createdAt
        
        do {
            try context.save()
            conversations.insert(conversation, at: 0)
            currentConversation = conversation
            messages = []
            pruneEmptyConversations(keeping: conversation)
        } catch {
            print("Error creating conversation: \(error)")
        }
    }
    
    func selectConversation(_ conversation: Conversation) {
        currentConversation = conversation
        loadMessages(for: conversation)
        pruneEmptyConversations(keeping: conversation)
    }
    
    func loadMessages(for conversation: Conversation) {
        let request = NSFetchRequest<Message>(entityName: "Message")
        request.predicate = NSPredicate(format: "conversation == %@", conversation)
        request.sortDescriptors = [NSSortDescriptor(key: "timestamp", ascending: true)]
        do {
            messages = try context.fetch(request)
        } catch {
            print("Error loading messages: \(error)")
            messages = []
        }
    }
    
    func sendMessage() {
        // 1) Guard + ensure we have/ create a conversation
        let typed = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        let hasAttachments = !pendingAttachments.isEmpty
        let modelAtSend = settings.model
        guard !typed.isEmpty || hasAttachments else { return }
        guard let conversation = currentConversation ?? createAndReturnNewConversation() else { return }
        
        // Mark last activity now so it jumps to the top immediately
        conversation.updatedAt = Date()
        try? context.save()

        // Optionally reorder in-memory list right away (keeps UI snappy)
        conversations.sort {
            ($0.updatedAt ?? $0.createdAt) > ($1.updatedAt ?? $1.createdAt)
        }

        self.webStatus = nil

        // 2) Build final user content
        let attachBlock = buildAttachmentsBlock()
        let finalUserContent = typed + (attachBlock.isEmpty ? "" : "\n\n" + attachBlock)

        // 3) Create the user message (not saved until stream completes)
        let userMessage = Message(context: context)
        userMessage.id = UUID()
        userMessage.content = finalUserContent
        userMessage.isUser = true
        userMessage.timestamp = Date()
        userMessage.conversation = conversation

        // If this is the first message, set a title from the typed text or first attachment name
        if messages.isEmpty {
            let titleSource: String = !typed.isEmpty ? typed : (pendingAttachments.first?.filename ?? "New Chat")
            conversation.title = String(titleSource.prefix(50))
        }

        messages.append(userMessage)

        // 4) Reset UI state and create an AI placeholder message
        inputText = ""
        isLoading = true
        streamedResponse = ""

        // attachments are now part of the outgoing message — clear the panel
        pendingAttachments.removeAll()

        let aiMessage = Message(context: context)
        aiMessage.id = UUID()
        aiMessage.content = ""
        aiMessage.isUser = false
        aiMessage.timestamp = Date()
        aiMessage.conversation = conversation
        aiMessage.modelName = modelAtSend
        messages.append(aiMessage)

        // 5) Token snapshot to guard against race conditions
        let tokenAtStart = streamToken

        // 6) Prepare fallback messages for "no web" path
        let apiMessages = messages
            .filter { $0.isUser || !$0.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
            .map { msg in
                ["role": msg.isUser ? "user" : "assistant", "content": msg.content]
            }

        // NEW: Start TTS session if enabled (speaks as chunks arrive)
        if settings.ttsEnabled { tts.beginStreaming() }

        if useWebSearch {
            // --- WEB path ---
            let filteredHistory = self.messages.filter {
                $0.isUser || !$0.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
            }

            pipelineTask = webPipeline.runSearchAndStream(
                question: finalUserContent,
                history: filteredHistory,
                service: lmStudioService,
                onChunk: { [weak self] chunk in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    self.streamedResponse += chunk
                    aiMessage.content = self.streamedResponse

                    // NEW: stream to TTS
                    if self.settings.ttsEnabled { self.tts.ingest(delta: chunk) }
                },
                onComplete: { [weak self] in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    self.isLoading = false
                    self.webStatus = nil

                    // NEW: flush any remaining TTS tail
                    if self.settings.ttsEnabled { self.tts.endStreaming() }

                    do {
                        try self.context.save()
                        if let conv = self.currentConversation { self.loadMessages(for: conv) }
                        self.loadConversations(preserveSelection: true)
                    } catch {
                        print("Error saving message: \(error)")
                    }
                },
                onError: { [weak self] error in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    print("[web] Web search error: \(error.localizedDescription)")
                    self.isLoading = false
                    self.webStatus = nil

                    // NEW: stop any ongoing speech
                    self.tts.stop()

                    let errorMessage = """
                    ⚠️ Web Search Error

                    The web search encountered an error and could not complete your request.

                    Error details: \(error.localizedDescription)

                    Please try again or disable web search to use offline mode.
                    """
                    aiMessage.content = errorMessage
                    do {
                        try self.context.save()
                        if let conv = self.currentConversation { self.loadMessages(for: conv) }
                        self.loadConversations(preserveSelection: true)
                    } catch {
                        print("Error saving error message: \(error)")
                    }
                },
                onStatus: { [weak self] status in
                    DispatchQueue.main.async { self?.webStatus = status }
                }
            )
        } else {
            // --- OFFLINE path ---
            lmStudioService.streamChat(
                messages: apiMessages,
                onChunk: { [weak self] chunk in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    self.streamedResponse += chunk
                    aiMessage.content = self.streamedResponse

                    // NEW: stream to TTS
                    if self.settings.ttsEnabled { self.tts.ingest(delta: chunk) }
                },
                onComplete: { [weak self] in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    self.isLoading = false

                    // NEW: flush any remaining TTS tail
                    if self.settings.ttsEnabled { self.tts.endStreaming() }

                    do {
                        try self.context.save()
                        if let conv = self.currentConversation { self.loadMessages(for: conv) }
                        self.loadConversations(preserveSelection: true)
                    } catch {
                        print("Error saving message: \(error)")
                    }
                },
                onError: { [weak self] error in
                    guard let self = self, self.streamToken == tokenAtStart else { return }
                    self.isLoading = false

                    // NEW: stop any ongoing speech
                    self.tts.stop()

                    aiMessage.content = "Error: \(error.localizedDescription)"
                    try? self.context.save()
                    self.loadConversations(preserveSelection: true)
                }
            )
        }
    }
    
    func stopEverything() {
        // Invalidate future callbacks
        streamToken = UUID()

        // Cancel network/stream/pipeline work
        lmStudioService.cancelStreaming()
        webPipeline.cancelRunning()
        pipelineTask?.cancel()
        pipelineTask = nil
        
        // NEW: also stop TTS
        tts.stop()

        // Reset UI state
        isLoading = false
        webStatus = nil

        // Optionally mark the last assistant message as partial (commented out)
        // if let last = messages.last(where: { !$0.isUser }) {
        //     last.content = last.content.trimmingCharacters(in: .whitespacesAndNewlines)
        //     if !last.content.isEmpty { last.content += "\n\n⏹️ Stopped." }
        // }

        // Persist whatever has streamed so far
        do { try context.save() } catch { print("Save after stop failed: \(error)") }
    }
    
    func editAndResend(from message: Message, newContent: String) {
        guard let conversation = currentConversation,
              let messageIndex = messages.firstIndex(where: { $0.objectID == message.objectID }) else { return }
        
        // Cancel any ongoing operations
        stopEverything()
        
        // Delete all messages from this one onwards
        let messagesToDelete = Array(messages.suffix(from: messageIndex))
        for msg in messagesToDelete {
            context.delete(msg)
        }
        messages.removeSubrange(messageIndex...)
        
        // Update conversation's updatedAt
        conversation.updatedAt = Date()
        
        // Save the deletion
        try? context.save()
        
        // Set input and send
        inputText = newContent
        sendMessage()
    }
    
    private func createAndReturnNewConversation() -> Conversation? {
        createNewConversation()
        return currentConversation
    }
    
    func deleteConversation(_ conversation: Conversation) {
        let id = conversation.objectID
        
        // If this is the current conversation, handle cleanup first
        if currentConversation?.objectID == id {
            // Cancel any in-flight operations immediately
            streamToken = UUID()
            
            // CRITICAL: Clear messages BEFORE any Core Data operations
            // This prevents the UI from trying to render soon-to-be-deleted objects
            messages.removeAll()
            
            // Find a replacement conversation
            var replacementConversation: Conversation? = nil
            
            if let currentIndex = conversations.firstIndex(where: { $0.objectID == id }) {
                // Try to select the previous conversation (more natural UX)
                if currentIndex > 0 {
                    replacementConversation = conversations[currentIndex - 1]
                } else if conversations.count > 1 && currentIndex + 1 < conversations.count {
                    // No previous, so select the next one
                    replacementConversation = conversations[currentIndex + 1]
                }
            }
            
            // Remove from in-memory list BEFORE Core Data deletion
            conversations.removeAll { $0.objectID == id }
            
            // Now safe to delete from Core Data
            context.delete(conversation)
            
            do {
                try context.save()
                
                // Update current conversation AFTER successful save
                if let replacement = replacementConversation {
                    currentConversation = replacement
                    loadMessages(for: replacement)
                } else {
                    // No other conversations exist - create new one
                    currentConversation = nil
                    createNewConversation()
                }
            } catch {
                print("Error deleting conversation: \(error)")
                // Restore the conversation to the list on error
                loadConversations(preserveSelection: false)
            }
        } else {
            // Not the current conversation, safe to delete immediately
            conversations.removeAll { $0.objectID == id }
            context.delete(conversation)
            
            do {
                try context.save()
            } catch {
                print("Error deleting conversation: \(error)")
                // Restore list on error
                loadConversations(preserveSelection: true)
            }
        }
    }
    
    func pruneEmptyConversations(keeping keep: Conversation? = nil) {
        let req = NSFetchRequest<Conversation>(entityName: "Conversation")
        var preds: [NSPredicate] = [NSPredicate(format: "messages.@count == 0")]
        if let keep = keep {
            preds.append(NSPredicate(format: "SELF != %@", keep))
        }
        req.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: preds)

        do {
            let empties = try context.fetch(req)
            guard !empties.isEmpty else { return }

            // Delete from Core Data
            empties.forEach { context.delete($0) }
            try context.save()

            // Also remove from in-memory list so UI updates immediately
            let removedIDs = Set(empties.map { $0.objectID })
            conversations.removeAll { removedIDs.contains($0.objectID) }
        } catch {
            print("Prune empty conversations failed: \(error)")
        }
    }
    
    func removeAttachment(_ id: UUID) {
        pendingAttachments.removeAll { $0.id == id }
    }

    @MainActor
    private func addAttachment(kind: Attachment.Kind, filename: String, text: String) {
        let t = ATTACHMENT_CHAR_LIMIT.map { text.clipped(to: $0) } ?? text
        pendingAttachments.append(Attachment(kind: kind, filename: filename, text: t))
    }

    // MARK: - Attachments processing

    func processPickedImageData(_ data: Data, suggestedName: String? = nil) {
        Task.detached(priority: .userInitiated) { [weak self] in
            guard let self else { return }
            guard let ui = UIImage(data: data),
                  let cg = ui.cgImage else { return }
            let text = Self.ocrText(from: cg)
            await MainActor.run {
                self.addAttachment(kind: .image, filename: suggestedName ?? "Photo.jpg", text: text)
            }
        }
    }

    func processPickedPDF(url: URL) {
        Task.detached(priority: .userInitiated) { [weak self] in
            guard let self else { return }
            var text = ""
            var didAccess = false
            if url.startAccessingSecurityScopedResource() {
                didAccess = true
            }
            defer { if didAccess { url.stopAccessingSecurityScopedResource() } }

            if let doc = PDFDocument(url: url) {
                for i in 0..<doc.pageCount {
                    if let page = doc.page(at: i), let s = page.string {
                        text += s + "\n"
                    }
                }
            }
            await MainActor.run {
                self.addAttachment(kind: .pdf, filename: url.lastPathComponent, text: text)
            }
        }
    }
    
    func deleteAllConversations() {
            // Cancel any in-flight operations
            streamToken = UUID()
            
            // Clear UI state immediately to prevent accessing deleted objects
            messages.removeAll()
            currentConversation = nil
            
            // Fetch all conversations from Core Data
            let request = NSFetchRequest<Conversation>(entityName: "Conversation")
            
            do {
                let allConversations = try context.fetch(request)
                
                // Delete each conversation from Core Data
                allConversations.forEach { context.delete($0) }
                
                // Save the context
                try context.save()
                
                // Clear the in-memory list
                conversations.removeAll()
                
                // Create a new empty conversation to start fresh
                createNewConversation()
                
            } catch {
                print("Error deleting all conversations: \(error)")
                // Reload conversations on error
                loadConversations(preserveSelection: false)
            }
        }

    private static func ocrText(from cgImage: CGImage) -> String {
        let req = VNRecognizeTextRequest()
        req.recognitionLevel = .accurate
        req.usesLanguageCorrection = true
        // Italian + English by default; add more if you like
        req.recognitionLanguages = ["it-IT", "en-US"]

        let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        do {
            try handler.perform([req])
            let lines = (req.results ?? []).compactMap { $0.topCandidates(1).first?.string }
            return lines.joined(separator: "\n")
        } catch {
            print("[OCR] error:", error.localizedDescription)
            return ""
        }
    }

    // Builds the block that will be appended to the user message
    private func buildAttachmentsBlock() -> String {
        guard !pendingAttachments.isEmpty else { return "" }
        var out = "### Attachments\n"
        for (idx, a) in pendingAttachments.enumerated() {
            out += "(\(idx + 1)) \(a.filename) [\(a.kind.rawValue)]\n"
            out += "```\n\(a.text)\n```\n\n"
        }
        return out
    }
}

fileprivate extension String {
    func clipped(to maxChars: Int) -> String {
        guard count > maxChars else { return self }
        return String(prefix(maxChars)) + "\n…[truncated]"
    }
    /// Truncate to `maxChars` total (including the "...").
        func truncatedWithDots(maxChars: Int) -> String {
            guard maxChars > 3, count > maxChars else { return self }
            let end = index(startIndex, offsetBy: maxChars - 3)
            return String(self[..<end]) + "..."
        }
}

// MARK: - Root (NavigationStack with list → chat)
struct ContentView: View {
    @ObservedObject var viewModel: ChatViewModel
    @EnvironmentObject private var settings: AppSettings

    @State private var showSidebar = false
    @State private var showSettings = false
    @State private var didLaunchNewChat = false
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding: Bool = false

    var body: some View {
        ZStack(alignment: .leading) {
            // Main chat screen in a nav stack so it has a title/toolbar
            NavigationStack {
                ChatView(
                    viewModel: viewModel,
                    onToggleSidebar: {
                        // dismiss keyboard first
                        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                        withAnimation(.easeOut) { showSidebar = true }
                    },
                    onOpenSettings: {
                        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                        showSettings = true
                    }
                )
            }

            // Slide-in conversations panel (max 70% width)
            SidebarOverlay(isShowing: $showSidebar) {
                ConversationPanelView(
                    viewModel: viewModel,
                    onOpen: { conv in
                        viewModel.selectConversation(conv)
                        withAnimation(.easeOut) { showSidebar = false }
                    },
                    onNewChat: {
                        viewModel.createNewConversation()
                        withAnimation(.easeOut) { showSidebar = false }
                    },
                    onOpenSettings: { showSettings = true }
                )
            }
        }
        // Settings sheet (same as you had)
        .sheet(isPresented: $showSettings) {
            NavigationStack {
                SettingsView(viewModel: viewModel)  // Pass the viewModel here
                    .environmentObject(settings)
                    .navigationTitle("Settings")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        ToolbarItem(placement: .topBarTrailing) {
                            Button("Done") { showSettings = false }
                        }
                    }
            }
            .presentationDetents([.large])
        }
        // Onboarding sheet - shows only on first launch
        .sheet(isPresented: Binding(
            get: { !hasCompletedOnboarding },
            set: { _ in }
        )) {
            OnboardingView()
        }
        // Start with a fresh chat every time the app launches
        .onAppear {
            Task { await ModelDownloadManager.shared.checkModelStatus() }
            guard !didLaunchNewChat else { return }
            didLaunchNewChat = true
            viewModel.createNewConversation()
        }
    }
}

// MARK: - Conversation List (replaces Sidebar)
struct ConversationPanelView: View {
    @ObservedObject var viewModel: ChatViewModel

    var onOpen: (Conversation) -> Void
    var onNewChat: () -> Void
    var onOpenSettings: () -> Void
    
    @State private var conversationToDelete: Conversation? = nil

    var body: some View {
        NavigationStack {
            List {
                if viewModel.conversations.isEmpty {
                    Section {
                        VStack(spacing: 12) {
                            Image(systemName: "message.circle")
                                .font(.system(size: 50))
                                .foregroundColor(.secondary)
                            Text("Start a conversation")
                                .font(.headline)
                                .foregroundColor(.secondary)
                            Button(action: onNewChat) {
                                Label("New Chat", systemImage: "plus.circle.fill")
                            }
                            .buttonStyle(.borderedProminent)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 32)
                        .listRowBackground(Color.clear)
                    }
                } else {
                    Section {
                        ForEach(
                            viewModel.conversations
                                .filter { !$0.isDeleted },
                            id: \.objectID
                        ) { conversation in
                            let title = conversation.title
                            let date  = conversation.createdAt
                            let isSelected = (viewModel.currentConversation?.objectID == conversation.objectID)

                            Button {
                                onOpen(conversation)
                            } label: {
                                ConversationRow(title: title, createdAt: date)
                                    .contentShape(Rectangle())
                                    .padding(.vertical, 4) // optional, for nicer spacing
                            }
                            .buttonStyle(.plain)
                            .listRowBackground(isSelected ? Color(.secondarySystemFill) : Color.clear)
                            .contextMenu {
                                Button(role: .destructive) {
                                    conversationToDelete = conversation
                                } label: {
                                    Label("Delete", systemImage: "trash")
                                }
                            }
                            .swipeActions { // ← optional, keep if you still want swipe-to-delete
                                Button(role: .destructive) {
                                    viewModel.deleteConversation(conversation)
                                } label: {
                                    Label("Delete", systemImage: "trash")
                                }
                            }
                        }
                    }
                }
            }
            .listStyle(.plain)
            .navigationTitle("Conversations")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button(action: onOpenSettings) {
                        CircleIcon(systemName: "gearshape",
                                   active: false,
                                   accessibilityLabel: "Settings")
                    }
                    .buttonStyle(.plain)
                }
            }
            .confirmationDialog(
                    "Delete this conversation?",
                    isPresented: Binding(
                        get: { conversationToDelete != nil },
                        set: { if !$0 { conversationToDelete = nil } }
                    ),
                    titleVisibility: .visible
                ) {
                    Button("Delete", role: .destructive) {
                        if let conv = conversationToDelete {
                            viewModel.deleteConversation(conv)
                        }
                        conversationToDelete = nil
                    }
                    Button("Cancel", role: .cancel) {
                        conversationToDelete = nil
                    }
                }
            #if os(iOS)
            .scrollContentBackground(.hidden)
            .background(Color(.systemGroupedBackground))
            #endif
        }
    }
}

struct ConversationRow: View {
    let title: String
    let createdAt: Date

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                    .lineLimit(1)
                Text(createdAt, style: .date)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            Image(systemName: "chevron.right")
                .font(.footnote)
                .foregroundColor(.white)
        }
        .contentShape(Rectangle())
    }
}

// MARK: - Chat Screen (iPhone)
struct ChatView: View {
    @ObservedObject var viewModel: ChatViewModel
    @FocusState private var isInputFocused: Bool
    @Environment(\.scenePhase) private var scenePhase
    @EnvironmentObject private var settings: AppSettings

    // NEW: auto-scroll toggler (true only when bottom sentinel is visible)
    @State private var autoScrollEnabled = true

    // Callbacks supplied by ContentView
    var onToggleSidebar: () -> Void = {}
    var onOpenSettings: () -> Void = {}

    var body: some View {
        ZStack {
            if settings.ttsEnabled {
                // Voice Only Mode: replace transcript with animated canvas
                VoiceOnlyCanvas(viewModel: viewModel)
                    .transition(.opacity.combined(with: .scale))
            } else {
                // Classic transcript UI
                messagesArea
            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .safeAreaInset(edge: .bottom) {
            ComposerBar(viewModel: viewModel, isInputFocused: _isInputFocused)
                .padding(.bottom, -4)
        }
        .toolbar {
            // Left
            ToolbarItem(placement: .topBarLeading) {
                Button(action: onToggleSidebar) {
                    CircleIcon(systemName: "sidebar.leading",
                               active: false,
                               accessibilityLabel: "Show conversations")
                }.buttonStyle(.plain)
            }

            // Center: model selector in title area
            ToolbarItem(placement: .principal) {
                ModelPickerMenu(onManage: onOpenSettings)
                    .environmentObject(settings)
            }

            // Right
            ToolbarItem(placement: .topBarTrailing) {
                Button {
                    if viewModel.isLoading { viewModel.stopEverything() }
                    viewModel.createNewConversation()
                } label: {
                    Image(systemName: "plus")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundStyle(.black)
                        .frame(width: 36, height: 36)
                        .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                .accessibilityLabel("New conversation")
            }
        }
        //.onAppear { isInputFocused = true }
        #if os(iOS)
        // Idle-timer control
        .onAppear {
            UIApplication.shared.isIdleTimerDisabled = viewModel.isLoading
        }
        .onChange(of: viewModel.isLoading) { isLoading in
            UIApplication.shared.isIdleTimerDisabled = isLoading
        }
        .onChange(of: scenePhase) { phase in
            if phase != .active { UIApplication.shared.isIdleTimerDisabled = false }
        }
        .onDisappear {
            UIApplication.shared.isIdleTimerDisabled = false
        }
        #endif
    }

    // MARK: - Classic Messages Area (shown when Voice Only mode is OFF)
    @ViewBuilder
    private var messagesArea: some View {
        ScrollViewReader { proxy in
            ZStack(alignment: .bottomTrailing) {
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 12) {
                        ForEach(
                            viewModel.messages
                                .filter { !$0.isDeleted }
                                .filter { $0.isUser || !$0.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty },
                            id: \.objectID
                        ) { message in
                            MessageBubble(message: message) { msg, newText in
                                viewModel.editAndResend(from: msg, newContent: newText)
                            }
                        }

                        if viewModel.useWebSearch,
                           let s = viewModel.webStatus,
                           viewModel.isLoading,
                           viewModel.streamedResponse.isEmpty {
                            InlineStatusRow(status: s)
                                .padding(.horizontal)
                                .transition(.opacity.combined(with: .move(edge: .bottom)))
                                .id("webStatusRow" as AnyHashable)
                        }

                        if viewModel.isLoading && viewModel.streamedResponse.isEmpty {
                            ThinkingBubble()
                                .id("thinking" as AnyHashable)
                        }

                        // Bottom sentinel used to detect if the user is at bottom
                        Color.clear
                            .frame(height: 1)
                            .id("bottom" as AnyHashable)
                            .onAppear { autoScrollEnabled = true }     // bottom visible → allow auto scroll
                            .onDisappear { autoScrollEnabled = false }  // scrolled up → freeze auto scroll
                    }
                    .padding(.horizontal)
                    .padding(.top)
                    .padding(.bottom, 16) // room above the inset composer
                }
                .scrollDismissesKeyboard(.interactively)
                // As soon as the user drags, freeze auto-scroll
                .simultaneousGesture(
                    DragGesture(minimumDistance: 1).onChanged { _ in autoScrollEnabled = false }
                )

                // Floating "Jump to latest" button when user has scrolled up
                if !autoScrollEnabled {
                    Button {
                        withAnimation {
                            proxy.scrollTo("bottom" as AnyHashable, anchor: .bottom)
                        }
                        autoScrollEnabled = true
                    } label: {
                        Image(systemName: "arrow.down")
                            .font(.system(size: 16, weight: .semibold))
                            .frame(width: 36, height: 36)
                            .background(Circle().fill(Color(.tertiarySystemFill)))
                            .foregroundStyle(.black) // ← force black (not blue)
                            .overlay(
                                Circle().stroke(Color.primary.opacity(0.08), lineWidth: 1)
                            )
                    }
                    .buttonStyle(.plain)
                    .accessibilityLabel("Jump to latest")
                    .padding(.trailing, 12)
                    .padding(.bottom, 76) // keep above the composer
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
            // Only auto-scroll when the bottom is visible (or re-enabled by the button)
            .onChange(of: viewModel.messages.count) { _ in
                guard autoScrollEnabled else { return }
                withAnimation { proxy.scrollTo("bottom" as AnyHashable, anchor: .bottom) }
            }
            .onChange(of: viewModel.streamedResponse) { _ in
                guard autoScrollEnabled else { return }
                withAnimation { proxy.scrollTo("bottom" as AnyHashable, anchor: .bottom) }
            }
            .onChange(of: viewModel.webStatus?.stage) { _ in
                guard autoScrollEnabled else { return }
                withAnimation { proxy.scrollTo("bottom" as AnyHashable, anchor: .bottom) }
            }
        }
    }
}

// MARK: - Composer (pinned above keyboard)
// MARK: - Composer (pinned above keyboard)
struct ComposerBar: View {
    @ObservedObject var viewModel: ChatViewModel
    @FocusState var isInputFocused: Bool
    @EnvironmentObject private var settings: AppSettings

    // Whisper
    @ObservedObject private var whisper = ModelDownloadManager.shared
    @StateObject private var transcriber = WhisperTranscriber()

    // Attachments UI state (kept for classic mode)
    @State private var showAttachMenu = false
    @State private var showPhotosPicker = false
    @State private var showPDFImporter = false
    @State private var pickedPhotoItem: PhotosPickerItem?

    private var canSend: Bool {
        let hasText = !viewModel.inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        let hasAttachments = !viewModel.pendingAttachments.isEmpty
        return !viewModel.isLoading && (hasText || hasAttachments) && settings.isChatConfigured
    }

    // Voice‑first UI is tied to the “Read replies aloud” setting
    private var isVoiceFirstMode: Bool { settings.ttsEnabled }

    var body: some View {
        VStack(spacing: 10) {
            // In voice-first mode we REMOVE the text field
            if !isVoiceFirstMode {
                messageField
            }

            // In voice-first mode we REMOVE the attachments strip
            if !isVoiceFirstMode {
                attachmentsStrip
            }

            if isVoiceFirstMode {
                controlsRowVoiceFirst
            } else {
                controlsRowClassic
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(.ultraThinMaterial)
        .clipShape(RoundedRectangle(cornerRadius: 18, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 18, style: .continuous)
                .stroke(Color.primary.opacity(0.06), lineWidth: 1)
        )
        .overlay(alignment: .bottom) {
            if !isVoiceFirstMode {
                Text("≈ \(pendingTokenCount.formatted()) tokens")
                    .font(.caption2.monospacedDigit())
                    .foregroundStyle(.secondary)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .padding(.bottom, 4)
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 6)

        // Voice transcript plumbing
        .onReceive(transcriber.$latestTranscript.compactMap { $0 }) { transcript in
            // Keep mirroring what Whisper heard into the buffer
            // (even in voice-first mode; we just don't show the text field)
            let hadFocus = isInputFocused
            viewModel.inputText = transcript
            isInputFocused = hadFocus
        }
        .onChange(of: transcriber.isRecording, perform: handleRecordingChange)

        // Auto-send after transcription finishes (voice-first mode only)
        .onChange(of: transcriber.isTranscribing) { isTranscribing in
            guard isVoiceFirstMode else { return }
            if !isTranscribing {
                autoSendAfterTranscriptionIfNeeded()
            }
        }

        // Pickers remain for classic mode
        .photosPicker(
            isPresented: $showPhotosPicker,
            selection: $pickedPhotoItem,
            matching: .images,
            preferredItemEncoding: .automatic
        )
        .fileImporter(
            isPresented: $showPDFImporter,
            allowedContentTypes: [.pdf],
            allowsMultipleSelection: false,
            onCompletion: handlePDFImport
        )
        .onChange(of: pickedPhotoItem, perform: handlePhotoChange)
    }

    // MARK: - Classic controls row (unchanged behavior)
    @ViewBuilder
    private var controlsRowClassic: some View {
        HStack(spacing: 10) {

            // Attachments
            Button { showAttachMenu = true } label: {
                Image(systemName: "paperclip")
                    .font(.system(size: 16, weight: .semibold))
                    .frame(width: 36, height: 36)
                    .background(Circle().fill(Color(.tertiarySystemFill)))
                    .foregroundStyle(.secondary)
                    .overlay(Circle().stroke(Color.primary.opacity(0.08), lineWidth: 1))
                    .accessibilityLabel("Add attachment")
            }
            .buttonStyle(.plain)
            .confirmationDialog("Add Attachment", isPresented: $showAttachMenu, titleVisibility: .visible) {
                Button("Photo from Library") { showPhotosPicker = true }
                Button("PDF from Files") { showPDFImporter = true }
                Button("Cancel", role: .cancel) { }
            }

            // Globe toggle
            globeButton

            Spacer(minLength: 8)

            // Mic (if supported & model ready)
            if DeviceSupport.isIPhone13OrNewer && whisper.isModelReady {
                smallMicButton
            }

            // Stop TTS (only when the setting is ON)
            if settings.ttsEnabled {
                stopTTSButton
            }

            // Stop (while streaming) or Send
            if viewModel.isLoading {
                stopStreamingButton
            } else {
                sendButton
            }
        }
    }

    // MARK: - Voice-first controls row
    @ViewBuilder
    private var controlsRowVoiceFirst: some View {
        HStack(spacing: 10) {

            // Left: only the globe toggle
            globeButton

            // Center: BIG, EXPANDING MIC (only when Whisper is ready)
            if DeviceSupport.isIPhone13OrNewer && whisper.isModelReady {
                Button {
                    // If currently recording, a tap stops the recording (unchanged)
                    if transcriber.isRecording {
                        transcriber.toggle()
                        return
                    }

                    // Voice-Only behavior: before starting a new recording,
                    // stop any ongoing stream + TTS so we don't talk over ourselves.
                    if viewModel.isTTSSpeaking || viewModel.isLoading {
                        viewModel.stopEverything()
                        // Give the audio session a beat to deactivate before recording
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                            if !transcriber.isTranscribing && !transcriber.isRecording {
                                transcriber.toggle()
                            }
                        }
                    } else if !transcriber.isTranscribing {
                        transcriber.toggle()
                    }
                } label: {
                    HStack(spacing: 8) {
                        if transcriber.isTranscribing {
                            ProgressView().progressViewStyle(.circular)
                            Text("Processing…")
                                .font(.system(size: 15, weight: .semibold))
                        } else if transcriber.isRecording {
                            Image(systemName: "mic.fill")
                                .font(.system(size: 18, weight: .bold))
                            Text("Listening… tap to stop")
                                .font(.system(size: 15, weight: .semibold))
                        } else {
                            Image(systemName: "mic.fill")
                                .font(.system(size: 18, weight: .semibold))
                            Text("Tap to speak")
                                .font(.system(size: 15, weight: .semibold))
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 44)
                    .contentShape(Rectangle())
                    .background(
                        Capsule().fill(Color(.tertiarySystemFill))
                    )
                    .foregroundStyle(.primary)
                    .overlay(
                        Capsule().stroke(
                            (transcriber.isRecording ? Color.red.opacity(0.35) : Color.primary.opacity(0.08)),
                            lineWidth: 1
                        )
                    )
                }
                .buttonStyle(.plain)
                // Don’t disable on isLoading anymore — we *want* taps to stop the stream then record
                .disabled(transcriber.isTranscribing)
                .accessibilityLabel(
                    transcriber.isRecording ? "Stop recording"
                    : (transcriber.isTranscribing ? "Processing speech" : "Start recording")
                )
            }

            // Right: a single Stop button (stops TTS and streaming)
            if viewModel.isTTSSpeaking || viewModel.isLoading {
                stopTTSButton
            }
        }
    }

    // MARK: - Reusable controls

    private var globeButton: some View {
        Button { viewModel.useWebSearch.toggle() } label: {
            Image(systemName: "globe")
                .font(.system(size: 16, weight: .semibold))
                .frame(width: 36, height: 36)
                .background(Circle().fill(viewModel.useWebSearch ? Color.black : Color(.tertiarySystemFill)))
                .foregroundStyle(viewModel.useWebSearch ? .white : .secondary)
                .overlay(
                    Circle().stroke(
                        viewModel.useWebSearch ? Color.black.opacity(0.35) : Color.primary.opacity(0.08),
                        lineWidth: 1
                    )
                )
                .accessibilityLabel(viewModel.useWebSearch ? "Web search on" : "Web search off")
        }
        .buttonStyle(.plain)
    }

    private var smallMicButton: some View {
        Button {
            if !transcriber.isTranscribing && !viewModel.isLoading {
                transcriber.toggle()
            }
        } label: {
            Group {
                if transcriber.isTranscribing {
                    ProgressView()
                        .progressViewStyle(.circular)
                        .frame(width: 36, height: 36)
                } else if transcriber.isRecording {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 16, weight: .bold))
                        .frame(width: 36, height: 36)
                } else {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 16, weight: .semibold))
                        .frame(width: 36, height: 36)
                }
            }
            .background(Circle().fill(Color(.tertiarySystemFill)))
            .foregroundStyle(transcriber.isRecording ? .red : .secondary)
            .overlay(
                Circle().stroke(
                    transcriber.isRecording ? Color.red.opacity(0.35) : Color.primary.opacity(0.08),
                    lineWidth: 1
                )
            )
        }
        .buttonStyle(.plain)
        .disabled(viewModel.isLoading || transcriber.isTranscribing)
        .accessibilityLabel(
            transcriber.isRecording ? "Stop recording"
            : (transcriber.isTranscribing ? "Processing speech" : "Start recording")
        )
    }

    private var stopTTSButton: some View {
        let canStop = viewModel.isTTSSpeaking || viewModel.isLoading

        return Button {
            // One tap stops both voice and network streaming
            viewModel.stopEverything()
        } label: {
            Image(systemName: "stop.fill")
                .font(.system(size: 15, weight: .bold))
                .frame(width: 36, height: 36)
                .background(
                    Circle().fill(canStop ? Color.red.opacity(0.18)
                                          : Color(.tertiarySystemFill))
                )
                .foregroundStyle(canStop ? .red : .secondary)
                .overlay(
                    Circle().stroke(
                        canStop ? Color.red.opacity(0.35)
                                : Color.primary.opacity(0.08),
                        lineWidth: 1
                    )
                )
        }
        .buttonStyle(.plain)
        .disabled(!canStop)
        .accessibilityLabel("Stop")
    }

    private var stopStreamingButton: some View {
        Button(role: .destructive) { viewModel.stopEverything() } label: {
            Image(systemName: "stop.fill")
                .font(.system(size: 15, weight: .bold))
                .frame(width: 36, height: 36)
                .background(Circle().fill(Color.red.opacity(0.18)))
                .foregroundStyle(.red)
                .overlay(Circle().stroke(Color.red.opacity(0.35), lineWidth: 1))
                .accessibilityLabel("Stop")
        }
        .buttonStyle(.plain)
    }

    private var sendButton: some View {
        Button {
            // Dismiss keyboard first
            isInputFocused = false
            UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
            viewModel.sendMessage()
        } label: {
            Image(systemName: "arrow.up")
                .font(.system(size: 16, weight: .semibold))
                .frame(width: 36, height: 36)
                .background(Circle().fill(canSend ? Color.black : Color(.tertiarySystemFill)))
                .foregroundStyle(canSend ? .white : .secondary)
                .overlay(
                    Circle().stroke(
                        canSend ? Color.black.opacity(0.35) : Color.primary.opacity(0.08),
                        lineWidth: 1
                    )
                )
                .accessibilityLabel("Send")
        }
        .buttonStyle(.plain)
        .disabled(!canSend)
    }

    // MARK: - Subviews kept from your original code

    @ViewBuilder
    private var messageField: some View {
        ZStack(alignment: .leading) {
            if viewModel.inputText.isEmpty {
                Text("Message…")
                    .foregroundStyle(.secondary)
                    .padding(.vertical, 10)
                    .padding(.horizontal, 6)
            }

            TextField("", text: $viewModel.inputText, axis: .vertical)
                .textFieldStyle(.plain)
                .lineLimit(1...8)
                .focused($isInputFocused)
                .textInputAutocapitalization(.sentences)
                .disableAutocorrection(false)
                .padding(.vertical, 10)
                .padding(.horizontal, 6)
                .background(Color.clear)
        }
    }

    @ViewBuilder
    private var attachmentsStrip: some View {
        if !viewModel.pendingAttachments.isEmpty {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(Array(viewModel.pendingAttachments.enumerated()), id: \.element.id) { idx, att in
                        AttachmentChip(
                            index: idx + 1,
                            attachment: att,
                            onRemove: { viewModel.removeAttachment(att.id) }
                        )
                    }
                }
                .padding(.horizontal, 2)
                .padding(.vertical, 4)
            }
        }
    }

    // MARK: - Token estimate
    private var pendingTokenCount: Int {
        let historyChars = viewModel.messages
            .filter { !$0.isDeleted }
            .filter { $0.isUser || !$0.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
            .map { $0.content.count }
            .reduce(0, +)

        let inputChars = viewModel.inputText.count

        let attachmentsChars = viewModel.pendingAttachments
            .map { $0.text.count }
            .reduce(0, +)

        return approxTokens(fromCharCount: historyChars + inputChars + attachmentsChars)
    }

    // MARK: - Handlers (kept/adapted)

    private func handlePDFImport(_ result: Result<[URL], Error>) {
        switch result {
        case .success(let urls):
            if let url = urls.first {
                viewModel.processPickedPDF(url: url)
            }
        case .failure(let err):
            print("[Importer] PDF pick error:", err.localizedDescription)
        }
    }

    private func handlePhotoChange(_ item: PhotosPickerItem?) {
        guard let item else { return }
        Task {
            if let data = try? await item.loadTransferable(type: Data.self) {
                await viewModel.processPickedImageData(data, suggestedName: nil)
            } else if let picked = try? await item.loadTransferable(type: PickedImage.self),
                      let data = picked.image.jpegData(compressionQuality: 0.9) {
                await viewModel.processPickedImageData(data, suggestedName: nil)
            } else if let url = try? await item.loadTransferable(type: URL.self),
                      let data = try? Data(contentsOf: url) {
                await viewModel.processPickedImageData(data, suggestedName: url.lastPathComponent)
            }
            pickedPhotoItem = nil
        }
    }

    private func handleRecordingChange(_ newValue: Bool) {
        if newValue { transcriber.latestTranscript = nil }
    }

    /// Auto-send the transcript once Whisper is done.
    private func autoSendAfterTranscriptionIfNeeded() {
        guard !viewModel.isLoading else { return } // don’t queue while streaming
        let text = (transcriber.latestTranscript ?? "").trimmingCharacters(in: .whitespacesAndNewlines)
        guard !text.isEmpty else { return }
        viewModel.inputText = text
        viewModel.sendMessage()
    }
}

private struct AttachmentChip: View {
    let index: Int
    let attachment: Attachment
    var onRemove: () -> Void

    var body: some View {
        HStack(spacing: 6) {
            Image(systemName: attachment.kind == .image ? "photo" : "doc.richtext")
                .imageScale(.small)
            Text("\(index). \(attachment.filename)")
                .lineLimit(1)
                .truncationMode(.middle)
            Button(action: onRemove) {
                Image(systemName: "xmark.circle.fill")
                    .imageScale(.small)
                    .foregroundStyle(.secondary)
                    .padding(.leading, 4)
            }
            .buttonStyle(.plain)
        }
        .font(.caption)
        .padding(.vertical, 6)
        .padding(.horizontal, 10)
        .background(
            Capsule().fill(Color(.tertiarySystemFill))
        )
        .overlay(
            Capsule().stroke(Color.primary.opacity(0.08), lineWidth: 1)
        )
    }
}

// MARK: - Message bubbles
struct MessageBubble: View {
    @ObservedObject var message: Message
    var onEdit: ((Message, String) -> Void)? = nil
    
    // Add state for the edit sheet
    @State private var showingEditSheet = false
    @State private var editedText = ""

    var body: some View {
        guard !message.isDeleted && !message.isFault else {
            return AnyView(EmptyView())
        }
        
        let isUser = message.isUser
        let content = message.content

        let (cleanText, parsedAttachments) = isUser
            ? splitUserContentAndAttachments(content)
            : (content, [])

        let copyText: String? = {
            if isUser {
                let t = cleanText.trimmingCharacters(in: .whitespacesAndNewlines)
                return t.isEmpty ? nil : t
            } else {
                let t = content.trimmingCharacters(in: .whitespacesAndNewlines)
                return t.isEmpty ? nil : t
            }
        }()

        return AnyView(
            HStack(spacing: 0) {
                if isUser { Spacer(minLength: 40) }

                VStack(alignment: isUser ? .trailing : .leading, spacing: 6) {

                    if isUser {
                        if !cleanText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            TableAwareMarkdown(text: cleanText, bubbleBackground: Color(.secondarySystemBackground))
                                .foregroundColor(.primary)
                                // ADD CONTEXT MENU HERE
                                .contextMenu {
                                    if let text = copyText {
                                        Button {
                                            UIPasteboard.general.string = text
                                        } label: {
                                            Label("Copy", systemImage: "doc.on.doc")
                                        }
                                        
                                        ShareLink(item: text) {
                                            Label("Share", systemImage: "square.and.arrow.up")
                                        }
                                    }
                                    
                                    // Edit at the bottom (third)
                                    if let onEdit = onEdit {
                                        Button {
                                            editedText = cleanText
                                            showingEditSheet = true
                                        } label: {
                                            Label("Edit & Resend", systemImage: "pencil")
                                        }
                                    }
                                }
                        }

                        if !parsedAttachments.isEmpty {
                            VStack(alignment: .trailing, spacing: 8) {
                                ForEach(parsedAttachments) { att in
                                    SentAttachmentView(att: att)
                                        .frame(maxWidth: 320, alignment: .trailing)
                                }
                            }
                        }
                    } else {
                        TableAwareMarkdown(text: content, bubbleBackground: .clear)
                            // Optional: add context menu for assistant messages too
                            .contextMenu {
                                if let text = copyText {
                                    Button {
                                        UIPasteboard.general.string = text
                                    } label: {
                                        Label("Copy", systemImage: "doc.on.doc")
                                    }
                                    
                                    ShareLink(item: text) {
                                        Label("Share", systemImage: "square.and.arrow.up")
                                    }
                                }
                            }
                    }

                    HStack(spacing: 8) {
                        Text(message.timestamp, style: .time)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        
                        if !isUser, let m = message.modelName, !m.isEmpty {
                            ModelTag(name: m)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: isUser ? .trailing : .leading)
                }
                .frame(maxWidth: .infinity, alignment: isUser ? .trailing : .leading)
            }
            .padding(.vertical, 2)
            // ADD SHEET FOR EDIT
            .sheet(isPresented: $showingEditSheet) {
                EditMessageSheet(
                    text: $editedText,
                    onSend: { newText in
                        onEdit?(message, newText)
                        showingEditSheet = false
                    },
                    onCancel: {
                        showingEditSheet = false
                    }
                )
            }
        )
    }
}

private enum MDChunk { case table(String), other(String) }

// Pipe-table separator matcher, e.g. `| --- | :---: | ---: |`
private let tableSeparatorRegex: NSRegularExpression = {
    try! NSRegularExpression(pattern: #"^\|?\s*:?-{3,}:?\s*(\|\s*:?-{3,}:?\s*)+\|?\s*$"#)
}()

/// Splits a markdown string into `.table` and `.other` chunks.
/// - Respects fenced code blocks (```) so tables inside code are ignored.
/// - Detects GitHub-style pipe tables: header row, then a separator row of dashes/colons.
private func markdownChunks(from text: String) -> [MDChunk] {
    let lines = text.split(omittingEmptySubsequences: false, whereSeparator: \.isNewline).map(String.init)
    var chunks: [MDChunk] = []
    var buffer: [String] = []
    var i = 0
    var inFence = false

    func flushOther() {
        guard !buffer.isEmpty else { return }
        chunks.append(.other(buffer.joined(separator: "\n")))
        buffer.removeAll()
    }

    while i < lines.count {
        let line = lines[i]
        let trimmed = line.trimmingCharacters(in: .whitespaces)

        // Track fenced code blocks (```lang)
        if trimmed.hasPrefix("```") {
            inFence.toggle()
            buffer.append(line)
            i += 1
            continue
        }

        // If not inside a code fence, look for a table header + separator
        if !inFence, i + 1 < lines.count,
           line.contains("|"),
           tableSeparatorRegex.firstMatch(
                in: lines[i + 1],
                options: [],
                range: NSRange(location: 0, length: lines[i + 1].utf16.count)
           ) != nil {

            // Emit accumulated non-table text
            flushOther()

            // Collect the table block: header + separator + subsequent pipe rows
            var tableLines = [line, lines[i + 1]]
            i += 2
            while i < lines.count {
                let L = lines[i]
                let t = L.trimmingCharacters(in: .whitespaces)
                if t.isEmpty || !L.contains("|") { break }
                tableLines.append(L)
                i += 1
            }
            chunks.append(.table(tableLines.joined(separator: "\n")))

            // Preserve a blank line after a table if it existed
            if i < lines.count, lines[i].trimmingCharacters(in: .whitespaces).isEmpty {
                buffer.append("")  // keep spacing
                i += 1
            }
            continue
        }

        // Default: accumulate normal lines
        buffer.append(line)
        i += 1
    }

    flushOther()
    return chunks
}

// Add this custom table parser and renderer

struct TableData {
    let headers: [String]
    let rows: [[String]]
    let alignments: [TextAlignment]
}

extension TableData {
    init?(from markdown: String) {
        let lines = markdown.split(separator: "\n").map(String.init)
        guard lines.count >= 2 else { return nil }
        
        // Parse header
        let headerLine = lines[0]
        let headers = headerLine
            .split(separator: "|")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        guard headers.count > 0 else { return nil }
        
        // Parse separator (for alignment info)
        let separatorLine = lines[1]
        let separatorParts = separatorLine
            .split(separator: "|")
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        
        let alignments = separatorParts.map { part -> TextAlignment in
            let trimmed = part.trimmingCharacters(in: .whitespaces)
            if trimmed.hasPrefix(":") && trimmed.hasSuffix(":") {
                return .center
            } else if trimmed.hasSuffix(":") {
                return .trailing
            } else {
                return .leading
            }
        }
        
        // Parse rows
        var rows: [[String]] = []
        for i in 2..<lines.count {
            let cells = lines[i]
                .split(separator: "|")
                .map { $0.trimmingCharacters(in: .whitespaces) }
                .filter { !$0.isEmpty }
            
            if cells.count > 0 {
                rows.append(cells)
            }
        }
        
        self.headers = headers
        self.rows = rows
        self.alignments = alignments.count == headers.count ? alignments : Array(repeating: .leading, count: headers.count)
    }
}

struct CustomTableView: View {
    let tableData: TableData
    let bubbleBackground: Color
    
    // Configuration
    let maxColumnCharacters: Int = 25
    let cellPadding: CGFloat = 8
    let minColumnWidth: CGFloat = 40
    
    private func estimatedWidth(for text: String) -> CGFloat {
        // Rough estimate: ~8 points per character for system font
        let charCount = min(text.count, maxColumnCharacters)
        return max(CGFloat(charCount * 8 + 16), minColumnWidth)
    }
    
    private func columnWidths() -> [CGFloat] {
        var widths: [CGFloat] = []
        
        for colIndex in 0..<tableData.headers.count {
            var maxWidth: CGFloat = estimatedWidth(for: tableData.headers[colIndex])
            
            for row in tableData.rows {
                if colIndex < row.count {
                    let cellWidth = estimatedWidth(for: row[colIndex])
                    maxWidth = max(maxWidth, cellWidth)
                }
            }
            
            // Cap the maximum width
            let maxAllowedWidth = CGFloat(maxColumnCharacters * 8 + 16)
            widths.append(min(maxWidth, maxAllowedWidth))
        }
        
        return widths
    }
    
    var body: some View {
        let widths = columnWidths()
        
        ScrollView(.horizontal, showsIndicators: true) {
            VStack(spacing: 0) {
                // Header row with uniform height
                EquiHeightHStack(spacing: 0) {
                    ForEach(Array(tableData.headers.enumerated()), id: \.offset) { index, header in
                        // Use Markdown for headers to support formatting
                        Markdown(header)
                            .markdownTextStyle(\.text) {
                                FontWeight(.bold)
                            }
                            .lineLimit(nil)
                            .multilineTextAlignment(
                                index < tableData.alignments.count ?
                                tableData.alignments[index] : .leading
                            )
                            .frame(width: widths[index], alignment: alignment(for: index))
                            .padding(cellPadding)
                            .frame(maxHeight: .infinity)
                            .background(Color.gray.opacity(0.1))
                            .overlay(
                                Rectangle()
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 0.5)
                            )
                    }
                }
                
                // Data rows with uniform height per row
                ForEach(Array(tableData.rows.enumerated()), id: \.offset) { rowIndex, row in
                    EquiHeightHStack(spacing: 0) {
                        ForEach(0..<tableData.headers.count, id: \.self) { colIndex in
                            let cellText = colIndex < row.count ? row[colIndex] : ""
                            
                            // Use Markdown for cell content to support formatting
                            Markdown(cellText)
                                .lineLimit(nil)
                                .multilineTextAlignment(
                                    colIndex < tableData.alignments.count ?
                                    tableData.alignments[colIndex] : .leading
                                )
                                .frame(width: widths[colIndex], alignment: alignment(for: colIndex))
                                .padding(cellPadding)
                                .frame(maxHeight: .infinity)
                                .background(
                                    rowIndex % 2 == 0 ?
                                    Color.clear :
                                    Color.gray.opacity(0.05)
                                )
                                .overlay(
                                    Rectangle()
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 0.5)
                                )
                        }
                    }
                }
            }
            .fixedSize(horizontal: false, vertical: true)
        }
        .scrollIndicators(.automatic)
    }
    
    private func alignment(for index: Int) -> Alignment {
        guard index < tableData.alignments.count else { return .leading }
        switch tableData.alignments[index] {
        case .leading: return .leading
        case .center: return .center
        case .trailing: return .trailing
        default: return .leading
        }
    }
}

// Helper view that ensures all children have equal height
struct EquiHeightHStack: Layout {
    var spacing: CGFloat = 0
    
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let heights = subviews.map { $0.sizeThatFits(proposal).height }
        let maxHeight = heights.max() ?? 0
        let widths = subviews.map { $0.sizeThatFits(proposal).width }
        let totalWidth = widths.reduce(0, +) + spacing * CGFloat(subviews.count - 1)
        
        return CGSize(width: totalWidth, height: maxHeight)
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let heights = subviews.map { $0.sizeThatFits(proposal).height }
        let maxHeight = heights.max() ?? 0
        
        var x = bounds.minX
        for subview in subviews {
            let width = subview.sizeThatFits(proposal).width
            let proposalWithHeight = ProposedViewSize(width: width, height: maxHeight)
            
            subview.place(
                at: CGPoint(x: x, y: bounds.minY),
                proposal: proposalWithHeight
            )
            
            x += width + spacing
        }
    }
}

// Updated TableAwareMarkdown view
struct TableAwareMarkdown: View {
    let text: String
    var bubbleBackground: Color = .clear

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            ForEach(Array(markdownChunks(from: text).enumerated()), id: \.offset) { _, chunk in
                switch chunk {
                case .other(let s):
                    Markdown(s)
                        .textSelection(.enabled)
                        .tint(.accentColor)
                        .frame(maxWidth: .infinity, alignment: .leading)

                case .table(let s):
                    // Try to parse as table data first
                    if let tableData = TableData(from: s) {
                        CustomTableView(tableData: tableData, bubbleBackground: bubbleBackground)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    } else {
                        // Fallback to regular markdown if parsing fails
                        ScrollView(.horizontal) {
                            Markdown(s)
                                .textSelection(.enabled)
                                .tint(.accentColor)
                                .fixedSize(horizontal: true, vertical: false)
                                .padding(.trailing, 12)
                        }
                        .scrollIndicators(.automatic)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    }
                }
            }
        }
        .padding(12)
        .background(bubbleBackground)
        .cornerRadius(12)
    }
}

struct ThinkingBubble: View {
    @State private var anim = false

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 6) {
                Text("Assistant")
                    .font(.caption)
                    .foregroundColor(.secondary)

                HStack(spacing: 6) {
                    ForEach(0..<3, id: \.self) { i in
                        Circle()
                            .frame(width: 8, height: 8)
                            .opacity(0.5)
                            .scaleEffect(anim ? 1.1 : 0.6)
                            .animation(
                                .easeInOut(duration: 0.6)
                                    .repeatForever()
                                    .delay(Double(i) * 0.2),
                                value: anim
                            )
                    }
                }
                .padding(12)
                .background(Color.gray.opacity(0.15))
                .cornerRadius(12)
            }
            Spacer(minLength: 40)
        }
        .onAppear { anim = true }
    }
}


struct SettingsView: View {
    @EnvironmentObject var settings: AppSettings
    @State private var showingCreate = false
    @State private var draftForCreate = EndpointConfig()
    @State private var showingDeleteAllAlert = false
    @ObservedObject private var whisper = ModelDownloadManager.shared
    
    let viewModel: ChatViewModel

    var body: some View {
        Form {
            endpointsSection
            webSearchSection
            voiceInputSection
            ttsSection
            dangerZoneSection  // Add this new section
                    }
                    #if os(iOS)
                    .scrollContentBackground(.hidden)
                    .background(Color(.systemGroupedBackground))
                    #endif
                    .navigationTitle("Settings")
                    .navigationBarTitleDisplayMode(.inline)
                    .sheet(isPresented: $showingCreate) {
                        NavigationStack {
                            EndpointDetailView(
                                draft: draftForCreate,
                                onSave: { endpoint in
                                    settings.upsertEndpoint(endpoint)
                                }
                            )
                            .environmentObject(settings)
                            .navigationTitle("New Endpoint")
                            .navigationBarTitleDisplayMode(.inline)
                        }
                        .presentationDetents([.large])
                    }
                    .alert("Delete All Conversations?", isPresented: $showingDeleteAllAlert) {
                        Button("Cancel", role: .cancel) { }
                        Button("Delete All", role: .destructive) {
                            viewModel.deleteAllConversations()
                        }
                    } message: {
                        Text("This will permanently delete all conversations and messages. This action cannot be undone.")
                    }
                    .task {
                        await whisper.checkModelStatus()
                    }
                }

    // MARK: - Sections

    @ViewBuilder
    private var endpointsSection: some View {
        Section {
            if settings.endpoints.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    Text("No endpoints saved.")
                        .foregroundStyle(.secondary)
                    Button {
                        draftForCreate = EndpointConfig()
                        showingCreate = true
                    } label: {
                        Label("Add Endpoint", systemImage: "plus.circle.fill")
                    }
                }
            } else {
                ForEach($settings.endpoints) { $endpoint in
                    NavigationLink {
                        EndpointDetailView(
                            draft: endpoint,
                            onSave: { edited in settings.upsertEndpoint(edited) }
                        )
                        .environmentObject(settings)
                    } label: {
                        HStack {
                            VStack(alignment: .leading, spacing: 2) {
                                Text(endpoint.name.isEmpty ? (URL(string: endpoint.apiBase)?.host ?? "Endpoint")
                                                           : endpoint.name)
                                    .font(.headline)
                                Text(endpoint.apiBase)
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                    .lineLimit(1)
                                    .truncationMode(.middle)
                            }
                            Spacer()
                            if settings.activeEndpointID == endpoint.id {
                                Text("Active").font(.caption2).foregroundStyle(.secondary)
                            }
                        }
                    }
                    .swipeActions {
                        Button(role: .destructive) {
                            settings.deleteEndpoint(endpoint)
                        } label: { Label("Delete", systemImage: "trash") }
                    }
                }

                Button {
                    draftForCreate = EndpointConfig()
                    showingCreate = true
                } label: {
                    Label("Add Endpoint", systemImage: "plus")
                }
            }
        } header: {
            Text("Endpoints")
        }
    }

    @ViewBuilder
    private var webSearchSection: some View {
        Section {
            // 1) Search key first (used only for SERP)
            SecretField("serper.dev API Key", text: $settings.serperApiKey)
                .font(.system(.body, design: .monospaced))
                .autocorrectionDisabled(true)
                .textInputAutocapitalization(.never)
            
            Text(
              "Web Search uses serper.dev. Insert your API Key. They offer a generous free tier package. This is required if you want to use Web Search."
            )
            .font(.footnote)
            .foregroundStyle(.secondary)

            // 2) Scraping mode selector
            Picker("Scraping Mode", selection: $settings.scrapingMode) {
                ForEach(ScrapingMode.allCases) { mode in
                    Text(mode.label).tag(mode)
                }
            }
            .pickerStyle(.segmented)

            // 3) Jina key only when Jina Reader is selected
            if settings.scrapingMode == .serperAPI { // ← rename to your case if needed
                SecretField("Jina Reader API Key", text: $settings.jinaApiKey)
                    .font(.system(.body, design: .monospaced))
                    .autocorrectionDisabled(true)
                    .textInputAutocapitalization(.never)
            }

            Text(
              "For higher quality scrapings go to jina.ai and get an API Key. Responses might take longer, though."
            )
            .font(.footnote)
            .foregroundStyle(.secondary)
        } header: {
            Text("Search & Scraping")
        }
        // Smoothly show/hide the Jina field when the selection changes
        .animation(.default, value: settings.scrapingMode)
    }
    
    @ViewBuilder
    private var voiceInputSection: some View {
        Section {
            // Status row
            HStack {
                Label("Status", systemImage: "waveform.circle")
                Spacer()
                Text(whisper.statusMessage)
                    .foregroundStyle(.secondary)
            }

            // Download progress (if any)
            if whisper.isDownloading {
                ProgressView(value: Double(whisper.downloadProgress))
                    .progressViewStyle(.linear)
                Text("Downloading… \(Int(whisper.downloadProgress * 100))%")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            // Actions based on state
            if !whisper.hasModelOnDisk {
                Button {
                    Task { await whisper.startDownload() }
                } label: {
                    Label("Download Whisper model (≈600 MB)", systemImage: "arrow.down.circle.fill")
                }
            } else if !whisper.isCompiled || !whisper.isModelReady {
                Button {
                    Task { await whisper.loadModel() }
                } label: {
                    Label("Compile model", systemImage: "cpu")
                }
                Text("Compilation happens once (and after app updates). Keep the app open.")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            } else {
                HStack(spacing: 8) {
                    Image(systemName: "checkmark.seal.fill").foregroundStyle(.green)
                    Text("Model ready. The microphone appears in the composer.")
                }
                .font(.callout)

                Button(role: .destructive) {
                    do { try whisper.deleteModelFromDisk() }
                    catch { print("[Whisper] delete error:", error.localizedDescription) }
                } label: {
                    Label("Remove model from device", systemImage: "trash")
                }
            }
        } header: {
            Text("Voice Input (whisper-large-v3-turbo)")
        } footer: {
            Text("Runs entirely on-device with WhisperKit. First compile can take a few minutes depending on device.")
        }
    }
    
    @ViewBuilder
        private var dangerZoneSection: some View {
            Section {
                Button(role: .destructive) {
                    showingDeleteAllAlert = true
                } label: {
                    HStack {
                        Image(systemName: "trash.fill")
                        Text("Delete All Conversations")
                    }
                    .frame(maxWidth: .infinity, alignment: .center)
                }
            } header: {
                Text("Danger Zone")
            } footer: {
                Text("Permanently removes all conversations and messages from this device.")
            }
        }
    
    @ViewBuilder
       private var ttsSection: some View {
           Section {
               Toggle("Enable Voice Only mode", isOn: $settings.ttsEnabled)
           } header: {
               Text("Voice Mode")
           } footer: {
               Text("This will work only if the transcription model is compiled.")
           }
       }
}

struct ModelBrowserView: View {
    @Binding var endpoint: EndpointConfig
    @EnvironmentObject private var settings: AppSettings  // ADD THIS

    @State private var searchText = ""
    @State private var allModels: [String] = []
    @State private var isLoading = false
    @State private var errorMessage: String?

    private var filteredModels: [String] {
        let q = searchText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !q.isEmpty else { return allModels }
        return allModels.filter { $0.localizedCaseInsensitiveContains(q) }
    }

    var body: some View {
        List {
            if isLoading {
                HStack(spacing: 8) {
                    ProgressView()
                    Text("Loading models…")
                }
            } else if let err = errorMessage {
                Label {
                    Text(err).font(.footnote)
                } icon: {
                    Image(systemName: "exclamationmark.triangle.fill")
                }
                .foregroundStyle(.secondary)
                Button("Retry") { Task { await loadModels() } }
            } else if allModels.isEmpty {
                Section {
                    Text("Server didn't expose /models (OpenAI-compatible) or /api/tags (Ollama), or returned an empty list.")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                    ManualAddModelsEditor(models: $endpoint.selectedModels, showSelectedList: false)
                }
            } else {
                Section {
                    ForEach(filteredModels, id: \.self) { id in
                        Button {
                            toggleSelection(id)
                        } label: {
                            HStack {
                                Text(id)
                                    .font(.system(.body, design: .monospaced))
                                    .lineLimit(1)
                                    .truncationMode(.middle)
                                Spacer()
                                Image(systemName: endpoint.selectedModels.contains(id) ? "checkmark.circle.fill" : "circle")
                                    .imageScale(.medium)
                                    .foregroundStyle(endpoint.selectedModels.contains(id) ? Color.accentColor : Color.secondary)
                            }
                        }
                        .buttonStyle(.plain)
                    }
                }
            }
        }
        .navigationTitle("Manage Models")
        .searchable(text: $searchText, placement: .navigationBarDrawer(displayMode: .always), prompt: "Search models")
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button("Clear All") { endpoint.selectedModels.removeAll() }
                .disabled(endpoint.selectedModels.isEmpty)
            }
        }
        .task { await loadModels() }
        .task(id: endpoint.apiBase) { await loadModels() }
        .task(id: endpoint.apiKey)  { await loadModels() }
        // ADD THIS: Auto-save on every model selection/deselection
        .onChange(of: endpoint) { newValue in
            settings.upsertEndpoint(newValue)
        }
    }

    @MainActor
    private func loadModels() async {
        isLoading = true
        errorMessage = nil
        allModels = []

        do {
            let client = ModelListClient(apiBase: endpoint.apiBase, apiKey: endpoint.apiKey)
            let models = try await client.fetchModels()
            allModels = models.sorted()

            if endpoint.preferredModel == nil || !(models.contains(endpoint.preferredModel!)) {
                endpoint.preferredModel = endpoint.selectedModels.first ?? models.first
            }
        } catch {
            errorMessage = error.localizedDescription
        }
        isLoading = false
    }

    private func toggleSelection(_ id: String) {
        if let idx = endpoint.selectedModels.firstIndex(of: id) {
            endpoint.selectedModels.remove(at: idx)
            if endpoint.preferredModel == id {
                endpoint.preferredModel = endpoint.selectedModels.first
            }
        } else {
            endpoint.selectedModels.append(id)
            if endpoint.preferredModel == nil { endpoint.preferredModel = id }
        }
    }
}

private struct ManualAddModelsEditor: View {
    @Binding var models: [String]
    @State private var customModel = ""
    var showSelectedList: Bool = true

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(spacing: 8) {
                TextField("e.g., qwen2.5:7b-instruct", text: $customModel)
                    .textFieldStyle(.roundedBorder)
                    .font(.system(.body, design: .monospaced))
                    .autocorrectionDisabled(true)
                    .textInputAutocapitalization(.never)
                Button("Add") {
                    let m = customModel.trimmingCharacters(in: .whitespacesAndNewlines)
                    guard !m.isEmpty else { return }
                    if !models.contains(m) { models.append(m) }
                    customModel = ""
                }
                .disabled(customModel.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }

            if showSelectedList, !models.isEmpty {
                ForEach(models, id: \.self) { id in
                    HStack {
                        Text(id)
                            .font(.system(.body, design: .monospaced))
                            .lineLimit(1).truncationMode(.middle)
                        Spacer()
                        Button(role: .destructive) {
                            models.removeAll { $0 == id }
                        } label: { Image(systemName: "trash") }
                        .buttonStyle(.plain)
                    }
                }
            }
        }
    }
}

// Minimal “show/hide” secure text entry with an eye button.
struct SecretField: View {
    let title: String
    @Binding var text: String
    @State private var reveal = false

    init(_ title: String, text: Binding<String>) {
        self.title = title
        self._text = text
    }

    var body: some View {
        HStack(spacing: 12) {
            Group {
                if reveal {
                    TextField(title, text: $text)
                } else {
                    SecureField(title, text: $text)
                }
            }
            .textContentType(.password)
            .textFieldStyle(.roundedBorder)

            Button {
                reveal.toggle()
            } label: {
                Image(systemName: reveal ? "eye.slash" : "eye")
                    .imageScale(.medium)
                    .foregroundStyle(.secondary)
            }
            .buttonStyle(.plain)
            .accessibilityLabel(reveal ? "Hide" : "Show")
        }
    }
}

struct WebPipelineStatusView: View {
    let status: WebStatus

    private var title: String {
        switch status.stage {
        case .generatingQueries: return "Generating queries…"
        case .analyzingResults:  return "Analyzing results…"
        case .scraping:          return "Scraping these URLs…"
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(spacing: 8) {
                ProgressView()
                Text(title).font(.headline)
            }

            if status.stage == .scraping && !status.urls.isEmpty {
                VStack(alignment: .leading, spacing: 4) {
                    ForEach(status.urls.prefix(4), id: \.self) { u in
                        Text(u)
                            .font(.caption)
                            .lineLimit(1)
                            .truncationMode(.middle)
                    }
                    if status.urls.count > 4 {
                        Text("…and \(status.urls.count - 4) more")
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
                .padding(.top, 2)
            }
        }
        .padding(12)
        .frame(maxWidth: .infinity, alignment: .leading) // ← make the bubble stretch
        .background(                                   // ← apply background AFTER the frame
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(Color(.systemGray4))            // darker grey
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .stroke(Color.primary.opacity(0.08), lineWidth: 1)
        )
        .transition(.opacity)
    }
}

struct SidebarOverlay<Content: View>: View {
    @Binding var isShowing: Bool
    let content: Content

    init(isShowing: Binding<Bool>, @ViewBuilder content: () -> Content) {
        self._isShowing = isShowing
        self.content = content()
    }

    var body: some View {
        GeometryReader { proxy in
            let panelWidth = min(proxy.size.width * 0.70, proxy.size.width)

            ZStack(alignment: .leading) {
                // Dim background when visible
                if isShowing {
                    Color.black.opacity(0.25)
                        .ignoresSafeArea()
                        .onTapGesture { withAnimation(.easeOut) { isShowing = false } }
                        .transition(.opacity)
                }

                // Panel itself
                content
                    .frame(width: panelWidth)
                    .background(.regularMaterial)
                    .shadow(radius: 8)
                    .offset(x: isShowing ? 0 : -panelWidth - 8)
                    .gesture(
                        DragGesture()
                            .onEnded { value in
                                // Swipe left to close
                                if value.translation.width < -50 {
                                    withAnimation(.easeOut) { isShowing = false }
                                }
                            }
                    )
            }
            .animation(.easeOut(duration: 0.25), value: isShowing)
        }
        .ignoresSafeArea()
    }
}

struct CircleIcon: View {
    let systemName: String
    var active: Bool = false
    var accessibilityLabel: String? = nil

    var body: some View {
        Image(systemName: systemName)
            .font(.system(size: 16, weight: .semibold))
            .frame(width: 36, height: 36)
            .background(
                Circle().fill(active ? Color.black : Color(.tertiarySystemFill))  // Changed from Color.accentColor
            )
            .foregroundStyle(active ? .white : .secondary)
            .overlay(
                Circle().stroke(
                    active ? Color.black.opacity(0.35)  // Changed from Color.accentColor.opacity(0.35)
                           : Color.primary.opacity(0.08),
                    lineWidth: 1
                )
            )
            .accessibilityLabel(accessibilityLabel ?? systemName)
    }
}

struct ModelListClient {
    let apiBase: String
    let apiKey: String

    func fetchModels() async throws -> [String] {
        // 1) Try OpenAI-compatible /v1/models (or base + /models)
        if let url = openAIModelsURL(from: apiBase) {
            var req = URLRequest(url: url)
            req.httpMethod = "GET"
            authHeaders(for: apiKey).forEach { k, v in req.setValue(v, forHTTPHeaderField: k) }

            let (data, resp) = try await URLSession.shared.data(for: req)
            if let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode),
               let list = try? JSONDecoder().decode(OpenAIModelList.self, from: data) {
                let ids = list.data.map(\.id).sorted()
                if !ids.isEmpty { return ids }
            }
        }

        // 2) Fallback: Ollama native list at /api/tags
        if let url = ollamaTagsURL(from: apiBase) {
            var req = URLRequest(url: url)
            req.httpMethod = "GET"
            let (data, resp) = try await URLSession.shared.data(for: req)
            if let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode),
               let tags = try? JSONDecoder().decode(OllamaTags.self, from: data) {
                let names = tags.models.map(\.name).sorted()
                if !names.isEmpty { return names }
            }
        }

        throw NSError(
            domain: "ModelListClient",
            code: -1,
            userInfo: [NSLocalizedDescriptionKey: "Couldn’t fetch models from /models or /api/tags."]
        )
    }

    // MARK: - Helpers

    private func openAIModelsURL(from base: String) -> URL? {
        let trimmed = base.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, let baseURL = URL(string: trimmed),
              let scheme = baseURL.scheme, (scheme == "http" || scheme == "https"),
              baseURL.host != nil else { return nil }
        return baseURL.appendingPathComponent("models")
    }

    private func ollamaTagsURL(from base: String) -> URL? {
        let trimmed = base.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, let baseURL = URL(string: trimmed),
              let scheme = baseURL.scheme, (scheme == "http" || scheme == "https"),
              baseURL.host != nil else { return nil }
        var comps = URLComponents(url: baseURL, resolvingAgainstBaseURL: false)
        comps?.path = "/api/tags"
        return comps?.url
    }

    private func authHeaders(for key: String) -> [String:String] {
        let trimmed = key.trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmed.isEmpty ? [:] : ["Authorization": "Bearer \(trimmed)"]
    }

    private struct OpenAIModelList: Decodable { let data: [OpenAIModel] }
    private struct OpenAIModel: Decodable { let id: String }
    private struct OllamaTags: Decodable { let models: [OllamaModel] }
    private struct OllamaModel: Decodable { let name: String }
}

struct ModelPickerMenu: View {
    @EnvironmentObject var settings: AppSettings
    var onManage: () -> Void = {}

    private func title(for ep: EndpointConfig) -> String {
        if !ep.name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty { return ep.name }
        // fallback to host of apiBase
        if let host = URL(string: ep.apiBase)?.host { return host }
        return "Endpoint"
    }

    var body: some View {
        Menu {
            if settings.endpoints.isEmpty {
                Button("Manage…", action: onManage)
            } else {
                ForEach(settings.endpoints) { ep in
                    if !ep.selectedModels.isEmpty {
                        Menu(title(for: ep)) {
                            ForEach(ep.selectedModels, id: \.self) { m in
                                Button {
                                    settings.setActiveModel(m, on: ep.id)
                                } label: {
                                    HStack {
                                        Text(m).font(.system(.body, design: .monospaced))
                                        if settings.activeEndpointID == ep.id && settings.model == m {
                                            Spacer()
                                            Image(systemName: "checkmark")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Divider()
                Button("Manage…", action: onManage)
            }
        } label: {
            if let _ = settings.activeEndpoint, !settings.model.isEmpty {
                Text(settings.model.truncatedWithDots(maxChars: 25))
                    .font(.headline)
                    .foregroundColor(.black)
                    .accessibilityLabel(settings.model) // keep full name for VoiceOver
            } else {
                HStack(spacing: 6) {
                    Image(systemName: "exclamationmark.triangle.fill").imageScale(.small)
                    Text("Select model").font(.headline)
                }
                .foregroundColor(.black)
            }
            }
            .pickerStyle(.menu)
            .labelsHidden()
            .frame(maxWidth: 240)
            .accentColor(.black)  // Add this line to make the menu indicator black
        }
}

struct EndpointDetailView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var settings: AppSettings

    @State var draft: EndpointConfig
    var onSave: (EndpointConfig) -> Void

    init(draft: EndpointConfig, onSave: @escaping (EndpointConfig) -> Void) {
        _draft = State(initialValue: draft)
        self.onSave = onSave
    }

    var body: some View {
        List {
            Section("Endpoint") {
                TextField("Name (e.g., LM Studio, OpenRouter)", text: $draft.name)
                    .textFieldStyle(.roundedBorder)

                TextField("Base URL...)", text: $draft.apiBase)
                    .textFieldStyle(.roundedBorder)
                    .font(.system(.body, design: .monospaced))
                    .keyboardType(.URL)
                    .textContentType(.URL)
                    .autocorrectionDisabled(true)
                    .textInputAutocapitalization(.never)

                SecretField("API Key (optional for local)", text: $draft.apiKey)
                    .font(.system(.body, design: .monospaced))
            }

            modelsSection
        }
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
        // Auto-save on every change to draft (name, apiBase, apiKey, selectedModels, preferredModel)
        .onChange(of: draft) { newValue in
            onSave(newValue)
        }
    }

    private var modelsSection: some View {
        Section("Models") {
            // Current selection summary
            if draft.selectedModels.isEmpty {
                Text("No models selected yet. Tap **Manage Models…** to browse, or add manually below.")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            } else {
                ForEach(draft.selectedModels, id: \.self) { id in
                    HStack {
                        Text(id)
                            .font(.system(.body, design: .monospaced))
                            .lineLimit(1)
                            .truncationMode(.middle)
                        Spacer()
                        Button(role: .destructive) {
                            draft.selectedModels.removeAll { $0 == id }
                            if draft.preferredModel == id { draft.preferredModel = draft.selectedModels.first }
                        } label: {
                            Image(systemName: "trash")
                        }
                        .buttonStyle(.plain)
                    }
                }
                if let pref = draft.preferredModel, !pref.isEmpty {
                    Text("Preferred: \(pref)")
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                }
                Text("\(draft.selectedModels.count) selected")
                    .font(.caption2)
                    .foregroundStyle(.secondary)
            }

            NavigationLink {
                ModelBrowserView(endpoint: $draft)
            } label: {
                Label("Manage Models…", systemImage: "list.bullet")
            }

            ManualAddModelsEditor(models: $draft.selectedModels, showSelectedList: false)
        }
    }
}

private struct InlineStatusRow: View {
    let status: WebStatus
    var body: some View {
        WebPipelineStatusView(status: status)
            .frame(maxWidth: .infinity, alignment: .leading) // full width, no "Assistant" label
    }
}

struct PickedImage: Transferable {
    let image: UIImage
    static var transferRepresentation: some TransferRepresentation {
        DataRepresentation(importedContentType: .image) { data in
            guard let ui = UIImage(data: data) else {
                throw NSError(domain: "Transfer", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid image data"])
            }
            return PickedImage(image: ui)
        }
    }
}


struct SentAttachmentView: View {
    let att: ParsedAttachment
    @State private var expanded = false

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(spacing: 8) {
                Image(systemName: att.kind == .image ? "photo" : "doc.richtext")
                    .imageScale(.medium)

                Text("\(att.index). \(att.filename)")
                    .font(.subheadline)
                    .lineLimit(1)
                    .truncationMode(.middle)

                Spacer()

                if !att.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    Button(expanded ? "Hide" : "View") {
                        withAnimation(.easeInOut) { expanded.toggle() }
                    }
                    .font(.caption)
                }

                Button {
                    UIPasteboard.general.string = att.text
                } label: {
                    Image(systemName: "doc.on.doc")
                        .imageScale(.medium)
                        .accessibilityLabel("Copy text")
                }
                .buttonStyle(.plain)
            }

            if expanded {
                ScrollView {
                    Text(att.text)
                        .font(.system(.footnote, design: .monospaced))
                        .textSelection(.enabled)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                .frame(maxHeight: 180)
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(Color(.tertiarySystemFill))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .stroke(Color.primary.opacity(0.08), lineWidth: 1)
        )
    }
}

private struct CopyToClipboardButton: View {
    let text: String
    @State private var copied = false

    var body: some View {
        Button {
            UIPasteboard.general.string = text
            copied = true
            // brief confirmation
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.2) { copied = false }
        } label: {
            HStack(spacing: 6) {
                Image(systemName: copied ? "checkmark" : "doc.on.doc")
                    .imageScale(.small)
                if copied {
                    Text("Copied")
                        .font(.caption2)
                }
            }
            .padding(.vertical, 4)
            .padding(.horizontal, 8)
            .foregroundStyle(copied ? .green : .secondary)
            .background(Capsule().fill(Color(.tertiarySystemFill)))
            .overlay(
                Capsule().stroke(Color.primary.opacity(0.08), lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
        .accessibilityLabel(copied ? "Copied" : "Copy to clipboard")
    }
}

private struct EditMessageButton: View {
    let originalText: String
    let onEdit: (String) -> Void
    
    @State private var showingEdit = false
    @State private var editedText = ""
    
    var body: some View {
        Button {
            editedText = originalText
            showingEdit = true
        } label: {
            Image(systemName: "pencil")
                // Thicker, more visible pencil
                .font(.system(size: 15, weight: .bold))
                // Make the glyph itself a bit bigger so it visually matches doc.on.doc
                .frame(width: 14, height: 18)
                .padding(.vertical, 4)
                .padding(.horizontal, 8)
                .foregroundStyle(.secondary)
                .background(Capsule().fill(Color(.tertiarySystemFill)))
                .overlay(
                    Capsule().stroke(Color.primary.opacity(0.08), lineWidth: 1)
                )
        }
        .buttonStyle(.plain)
        .accessibilityLabel("Edit message")
        .sheet(isPresented: $showingEdit) {
            EditMessageSheet(
                text: $editedText,
                onSend: { newText in
                    onEdit(newText)
                    showingEdit = false
                },
                onCancel: {
                    showingEdit = false
                }
            )
        }
    }
}

private struct EditMessageSheet: View {
    @Binding var text: String
    let onSend: (String) -> Void
    let onCancel: () -> Void
    @FocusState private var isFocused: Bool
    
    private var canSend: Bool {
        !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    var body: some View {
        NavigationStack {
            TextEditor(text: $text)
                .focused($isFocused)
                .padding()
                .navigationTitle("Edit Message")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .cancellationAction) {
                        Button("Cancel", action: onCancel)
                    }
                    ToolbarItem(placement: .confirmationAction) {
                        Button("Send") {
                            onSend(text)
                        }
                        .fontWeight(.semibold)
                        .disabled(!canSend)
                    }
                }
        }
        .presentationDetents([.medium, .large])
        .onAppear { isFocused = true }
    }
}

private struct ModelTag: View {
    let name: String
    var body: some View {
        Text(name.truncatedWithDots(maxChars: 35))
            .font(.caption2)
            .foregroundStyle(.secondary)
            .lineLimit(1)
    }
}

fileprivate func approxTokens(fromCharCount n: Int) -> Int {
    Int(ceil(Double(n) / 3.8))
}

// MARK: - TTS (streaming, sentence-level)
final class TTSManager: NSObject, ObservableObject {
    @Published private(set) var isSpeaking = false

    private let synth = AVSpeechSynthesizer()
    private var buffer = ""
    private var processedCount = 0
    private var sessionActive = false

    // NEW: language detection + voice cache
    private let langRecognizer = NLLanguageRecognizer()
    private var lastVoice: AVSpeechSynthesisVoice?
    private var lastLanguageTag: String?

    override init() {
        super.init()
        synth.delegate = self
    }

    func beginStreaming() {
        buffer.removeAll()
        processedCount = 0
        isSpeaking = false
        lastVoice = nil
        lastLanguageTag = nil
        startAudioSessionIfNeeded()
    }

    func ingest(delta: String) {
        guard !delta.isEmpty else { return }
        buffer += delta
        speakCommittedSentences()
    }

    func endStreaming() {
        guard processedCount < buffer.count else { return }
        let start = buffer.index(buffer.startIndex, offsetBy: processedCount)
        let tail = String(buffer[start..<buffer.endIndex]).trimmingCharacters(in: .whitespacesAndNewlines)
        if !tail.isEmpty {
            enqueueUtterance(for: tail)
            processedCount = buffer.count
        }
    }

    func stop() {
        synth.stopSpeaking(at: .immediate)
        processedCount = buffer.count
        buffer.removeAll()
        isSpeaking = false
        stopAudioSessionIfNeeded()
    }

    // MARK: - Commit/split as before
    private func speakCommittedSentences() {
        guard processedCount < buffer.count else { return }
        let commitIdx = lastSentenceBoundaryIndex(in: buffer, fromOffset: processedCount)
        guard commitIdx > processedCount else { return }

        let start = buffer.index(buffer.startIndex, offsetBy: processedCount)
        let end   = buffer.index(buffer.startIndex, offsetBy: commitIdx)
        let chunk = buffer[start..<end]

        let parts = chunk.split(whereSeparator: { $0 == "\n" || $0 == "\r" })
        if parts.isEmpty {
            enqueueUtterance(for: String(chunk))
        } else {
            parts.forEach { enqueueUtterance(for: String($0)) }
        }
        processedCount = commitIdx
    }

    private func lastSentenceBoundaryIndex(in text: String, fromOffset: Int) -> Int {
        if text.isEmpty { return fromOffset }
        let terminators: Set<Character> = [".", "?", "!", "…", "\n"]
        var lastIdx: Int? = nil
        var idx = 0
        var prevWasNewline = false

        for ch in text {
            let pos = idx; idx += 1
            if pos <= fromOffset {
                prevWasNewline = (ch == "\n"); continue
            }
            if ch == "\n" && prevWasNewline { lastIdx = pos + 1 }
            else if terminators.contains(ch) { lastIdx = pos + 1 }
            prevWasNewline = (ch == "\n")
        }
        return lastIdx ?? fromOffset
    }

    // MARK: - Language detection + voice selection
    private func enqueueUtterance(for text: String) {
        // Sanitize first so language detection & speech ignore emojis
        let clean = sanitizedForSpeech(text)
        guard !clean.isEmpty else { return }

        let langTag = detectLanguageBCP47(for: clean) ?? lastLanguageTag ?? Locale.current.identifier
        let voice = bestVoice(matching: langTag)
                    ?? lastVoice
                    ?? AVSpeechSynthesisVoice(language: Locale.current.identifier)

        let u = AVSpeechUtterance(string: clean)
        u.voice = voice
        u.rate = AVSpeechUtteranceDefaultSpeechRate
        u.preUtteranceDelay = 0
        u.postUtteranceDelay = 0

        lastVoice = voice
        lastLanguageTag = voice?.language
        synth.speak(u)
    }

    /// Returns a full BCP-47 tag (e.g. "it-IT") when possible.
    private func detectLanguageBCP47(for text: String) -> String? {
        langRecognizer.reset()
        langRecognizer.processString(text)
        guard let lang = langRecognizer.dominantLanguage else { return nil }
        let twoLetter = lang.rawValue.lowercased() // e.g., "it", "en"

        // If a concrete voice exists for this family, return its full tag.
        if let v = bestVoice(matching: twoLetter) {
            return v.language // e.g., "it-IT"
        }
        // Fall back to 2-letter tag (AVSpeech can still find a default)
        return twoLetter
    }

    /// Finds the nicest installed voice matching an exact tag or a language prefix.
    private func bestVoice(matching languageOrPrefix: String) -> AVSpeechSynthesisVoice? {
        // Exact tag first (e.g., "it-IT")
        if let exact = AVSpeechSynthesisVoice(language: languageOrPrefix) { return exact }

        // Then by prefix ("it" → any it-*), preferring Enhanced quality when present
        let lower = languageOrPrefix.lowercased()
        let candidates = AVSpeechSynthesisVoice.speechVoices()
            .filter { $0.language.lowercased().hasPrefix(lower) }
        return candidates.first(where: { $0.quality == .enhanced }) ?? candidates.first
    }

    private func startAudioSessionIfNeeded() {
        guard !sessionActive else { return }
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .spokenAudio, options: [.duckOthers])
            try AVAudioSession.sharedInstance().setActive(true)
            sessionActive = true
        } catch {
            print("[TTS] audio session error:", error.localizedDescription)
        }
    }

    private func stopAudioSessionIfNeeded() {
        guard sessionActive else { return }
        do {
            try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
            sessionActive = false
        } catch {
            print("[TTS] audio session deactivate error:", error.localizedDescription)
        }
    }
    
    /// Remove emojis & common emoticons so TTS won't read them.
    private func sanitizedForSpeech(_ text: String) -> String {
        // 1) Remove emoji-like grapheme clusters (but keep plain digits/#/* when not emoji)
        var noEmoji = ""
        noEmoji.reserveCapacity(text.count)
        for ch in text {
            noEmoji.append(ch.isEmojiLikeForSpeech ? " " : ch) // keep a space to avoid word-gluing
        }

        // 2) Strip common emoticons and :shortcodes: with boundaries to avoid eating legit text
        var cleaned = noEmoji

        // Emoticons like :) ;-) :D :p and <3, but only when not embedded in words
        let emoticons = #"(?<!\w)(?:[;:=8xX]-?[\)\(DdPp]|<3)(?!\w)"#
        cleaned = cleaned.replacingOccurrences(of: emoticons, with: " ", options: .regularExpression)

        // Slack/GitHub-style shortcodes, e.g., :smile:, :thumbs_up:
        // Require non-word boundaries so :C++: in code blocks is still caught, but
        // things like "path:/usr/local:" won't match because there isn't a trailing colon-word-colon shape.
        let shortcodes = #"(?<!\w):[A-Za-z0-9_+\-]{1,30}:(?!\w)"#
        cleaned = cleaned.replacingOccurrences(of: shortcodes, with: " ", options: .regularExpression)

        // 3) Tidy whitespace and spacing before punctuation
        cleaned = cleaned
            .replacingOccurrences(of: #"\s{2,}"#, with: " ", options: .regularExpression)
            .replacingOccurrences(of: #"\s+([,.!?;:])"#, with: "$1", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)

        return cleaned
    }
}

extension TTSManager: AVSpeechSynthesizerDelegate {
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {
        DispatchQueue.main.async { self.isSpeaking = true }
    }
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        if !synthesizer.isSpeaking {
            DispatchQueue.main.async { self.isSpeaking = false }
        }
    }
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance) {
        if !synthesizer.isSpeaking {
            DispatchQueue.main.async { self.isSpeaking = false }
        }
    }
}

// MARK: - Voice Only Canvas
struct VoiceOnlyCanvas: View {
    @ObservedObject var viewModel: ChatViewModel

    var body: some View {
        VStack(spacing: 18) {
            // NEW: token pill under the nav/model selector
            TokenCountPill(count: viewModel.tokenEstimate)
                .padding(.top, 6)

            // Keep some breathing room before the sphere
            Spacer(minLength: 8)

            // Big animated sphere
            PulseSphere(isActive: viewModel.isTTSSpeaking)
                .frame(width: 180, height: 180)
                .accessibilityHidden(true)

            // Headline status text
            Text(statusHeadline)
                .font(.headline)
                .multilineTextAlignment(.center)
                .foregroundStyle(.primary)
                .padding(.horizontal)

            if viewModel.isLoading && viewModel.streamedResponse.isEmpty {
                ThinkingDotsInline()
                    .padding(.top, 4)
            }

            if viewModel.useWebSearch,
               let s = viewModel.webStatus,
               viewModel.isLoading,
               viewModel.streamedResponse.isEmpty {
                InlineStatusRow(status: s)
                    .padding(.horizontal)
            }

            Spacer(minLength: 24)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        #if os(iOS)
        .background(Color(.systemGroupedBackground))
        #endif
        .transition(.opacity.combined(with: .scale))
    }

    private var statusHeadline: String {
        if viewModel.isTTSSpeaking { return "" }
        if viewModel.isLoading {
            return viewModel.useWebSearch && viewModel.webStatus != nil
                ? "Searching the web and thinking…"
                : "Thinking…"
        }
        return ""
    }
}

// MARK: - Animated Pulse Sphere
/// A soft, breathing sphere. It is still when `isActive` is false and gently
/// pulses only when `isActive` is true.
struct PulseSphere: View {
    var isActive: Bool
    @State private var t: Double = 0

    // Tweak these for feel
    private let period: Double = 1.2   // seconds per breath
    private let amplitude: CGFloat = 0.06

    var body: some View {
        TimelineView(.animation) { timeline in
            let now = timeline.date.timeIntervalSinceReferenceDate
            // progress in [0, 1]
            let progress = 0.5 + 0.5 * sin(2 * .pi * (now / period))
            let scale: CGFloat = isActive ? (1.0 + amplitude * CGFloat(progress)) : 1.0
            let glow = isActive ? 0.35 : 0.12

            ZStack {
                // Subtle outer ring that softly grows/shrinks when active
                Circle()
                    .strokeBorder(Color.accentColor.opacity(isActive ? 0.25 : 0.10), lineWidth: 2)
                    .scaleEffect(isActive ? (1.06 + 0.02 * CGFloat(progress)) : 1.0)
                    .blur(radius: isActive ? 1.5 : 0)

                // Core sphere
                Circle()
                    .fill(
                        RadialGradient(
                            gradient: Gradient(colors: [
                                Color.accentColor.opacity(0.9),
                                Color.accentColor.opacity(0.6),
                                Color.accentColor.opacity(0.28),
                                Color.accentColor.opacity(0.18)
                            ]),
                            center: .center,
                            startRadius: 6,
                            endRadius: 180
                        )
                    )
                    .overlay(
                        // Soft highlight
                        Circle()
                            .fill(.white.opacity(0.10))
                            .blur(radius: 18)
                            .offset(y: -24)
                            .mask(Circle())
                    )
                    .scaleEffect(scale)
                    .shadow(color: Color.accentColor.opacity(glow), radius: isActive ? 28 : 10, x: 0, y: 10)

                // Gentle ripples when active
                if isActive {
                    RippleRing(progress: progress, delay: 0.0)
                    RippleRing(progress: progress, delay: 0.33)
                    RippleRing(progress: progress, delay: 0.66)
                }
            }
            .animation(.linear(duration: 0), value: isActive) // timeline drives motion
        }
        .aspectRatio(1, contentMode: .fit)
    }

    /// Expanding, fading rings synchronized to `progress`.
    @ViewBuilder
    private func RippleRing(progress: Double, delay: Double) -> some View {
        let p = (progress + delay).truncatingRemainder(dividingBy: 1)
        let ringScale = 1.05 + (0.25 * p)
        let opacity = Double(max(0, 0.35 - 0.35 * p))

        Circle()
            .stroke(Color.accentColor.opacity(opacity), lineWidth: 1.5)
            .scaleEffect(ringScale)
            .blur(radius: 0.5)
    }
}

// MARK: - Inline thinking dots (centered, minimal)
struct ThinkingDotsInline: View {
    @State private var anim = false

    var body: some View {
        HStack(spacing: 8) {
            ForEach(0..<3, id: \.self) { i in
                Circle()
                    .frame(width: 8, height: 8)
                    .opacity(0.6)
                    .scaleEffect(anim ? 1.15 : 0.65)
                    .animation(
                        .easeInOut(duration: 0.6)
                            .repeatForever()
                            .delay(Double(i) * 0.18),
                        value: anim
                    )
            }
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 14)
        .background(
            Capsule().fill(Color.gray.opacity(0.15))
        )
        .overlay(
            Capsule().stroke(Color.primary.opacity(0.08), lineWidth: 1)
        )
        .onAppear { anim = true }
    }
}

extension ChatViewModel {
    /// Approximate prompt tokens for the *pending* send (history + input + attachments).
    var tokenEstimate: Int {
        let historyChars = messages
            .filter { !$0.isDeleted }
            .filter { $0.isUser || !$0.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
            .map { $0.content.count }
            .reduce(0, +)

        let inputChars = inputText.count

        let attachmentsChars = pendingAttachments
            .map { $0.text.count }
            .reduce(0, +)

        return approxTokens(fromCharCount: historyChars + inputChars + attachmentsChars)
    }
}

struct TokenCountPill: View {
    let count: Int
    var body: some View {
        Text("≈ \(count.formatted()) tokens")
            .font(.caption2.monospacedDigit())
            .foregroundStyle(.secondary)
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                Capsule().fill(Color(.secondarySystemBackground))
            )
            .overlay(
                Capsule().stroke(Color.primary.opacity(0.08), lineWidth: 1)
            )
            .accessibilityLabel("Estimated tokens")
    }
}

private extension Character {
    /// True for things that *visually* render as emoji: pictographs, ZWJ sequences,
    /// keycaps (1️⃣, #️⃣), flags, or when VS16 forces emoji presentation.
    var isEmojiLikeForSpeech: Bool {
        let scalars = unicodeScalars

        // Any scalar that defaults to emoji presentation (😀, 👍, etc.)
        if scalars.contains(where: { $0.properties.isEmojiPresentation }) { return true }

        // Variation Selector-16 forces emoji presentation on otherwise texty scalars
        if scalars.contains(where: { $0.value == 0xFE0F }) { return true } // VS16

        // ZWJ joins (family/man-woman-boy, profession emojis, etc.)
        if scalars.contains(where: { $0.value == 0x200D }) { return true } // ZWJ

        // Keycap sequences like 1️⃣, #️⃣, *️⃣
        if scalars.contains(where: { $0.value == 0x20E3 }) { return true } // COMBINING ENCLOSING KEYCAP

        // Regional indicator flags are two scalars in 1F1E6–1F1FF
        if scalars.count == 2,
           scalars.allSatisfy({ (0x1F1E6...0x1F1FF).contains(Int($0.value)) }) { return true }

        // Skin tone modifiers imply an emoji sequence when present
        if scalars.contains(where: { (0x1F3FB...0x1F3FF).contains(Int($0.value)) }) { return true }

        return false
    }
}


enum KeychainHelper {
    
    static func save(_ data: String, for key: String) {
        guard let data = data.data(using: .utf8) else { return }
        
        // Delete any existing item first
        let deleteQuery: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key
        ]
        SecItemDelete(deleteQuery as CFDictionary)
        
        // Add new item
        let addQuery: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock
        ]
        SecItemAdd(addQuery as CFDictionary, nil)
    }
    
    static func load(for key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let string = String(data: data, encoding: .utf8) else {
            return nil
        }
        return string
    }
    
    static func delete(for key: String) {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key
        ]
        SecItemDelete(query as CFDictionary)
    }
}
